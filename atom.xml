<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>muyin568</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-04-17T00:58:00.470Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>muyin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>freertos-que</title>
    <link href="http://example.com/wiki/freertos-que/"/>
    <id>http://example.com/wiki/freertos-que/</id>
    <published>2025-04-17T00:49:20.000Z</published>
    <updated>2025-04-17T00:58:00.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="QueueDefinition-结构体"><a href="#QueueDefinition-结构体" class="headerlink" title="QueueDefinition 结构体"></a><code>QueueDefinition</code> 结构体</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------+</span><br><span class="line">|                QueueDefinition                      |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  int8_t *pcHead;                                    |  &lt;-- 指向队列存储区的开始位置</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  int8_t *pcWriteTo;                                 |  &lt;-- 指向队列下一个可写位置</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  union                                              |</span><br><span class="line">|  &#123;                                                  |</span><br><span class="line">|    QueuePointers_t xQueue;                          |  &lt;-- 使用队列时需要的相关数据</span><br><span class="line">|    SemaphoreData_t xSemaphore;                      |  &lt;-- 使用信号量时需要的相关数据</span><br><span class="line">|  &#125; u;                                               |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  List_t xTasksWaitingToSend;                        |  &lt;-- 存储等待发送到队列的任务（按优先级顺序）</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  List_t xTasksWaitingToReceive;                     |  &lt;-- 存储等待从队列接收数据的任务（按优先级顺序）</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  volatile UBaseType_t uxMessagesWaiting;            |  &lt;-- 当前队列中的项目数</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  UBaseType_t uxLength;                              |  &lt;-- 队列的长度（队列可以容纳的项的数量）</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  UBaseType_t uxItemSize;                            |  &lt;-- 队列每个项的大小</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  volatile int8_t cRxLock;                           |  &lt;-- 存储队列接收锁定期间接收的项目数量</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  volatile int8_t cTxLock;                           |  &lt;-- 存储队列发送锁定期间传输的项目数量</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) &amp;&amp;  |</span><br><span class="line">|       ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )   |</span><br><span class="line">|    uint8_t ucStaticallyAllocated;                   |  &lt;-- 如果队列内存是静态分配的，则为 pdTRUE</span><br><span class="line">|  #endif                                             |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  #if ( configUSE_QUEUE_SETS == 1 )                  |</span><br><span class="line">|    struct QueueDefinition * pxQueueSetContainer;    |  &lt;-- 队列所在的队列集容器（如果启用队列集）</span><br><span class="line">|  #endif                                             |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|  #if ( configUSE_TRACE_FACILITY == 1 )              |</span><br><span class="line">|    UBaseType_t uxQueueNumber;                       |  &lt;-- 队列的唯一标识符</span><br><span class="line">|    uint8_t ucQueueType;                             |  &lt;-- 队列类型（队列或信号量）</span><br><span class="line">|  #endif                                             |</span><br><span class="line">+-----------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;QueueDefinition-结构体&quot;&gt;&lt;a href=&quot;#QueueDefinition-结构体&quot; class=&quot;headerlink&quot; title=&quot;QueueDefinition 结构体&quot;&gt;&lt;/a&gt;&lt;code&gt;QueueDefinition&lt;/code&gt; </summary>
      
    
    
    
    <category term="freeRTOS" scheme="http://example.com/categories/freeRTOS/"/>
    
    
    <category term="freeRTOS" scheme="http://example.com/tags/freeRTOS/"/>
    
  </entry>
  
  <entry>
    <title>freertos-overview &amp;&amp; task</title>
    <link href="http://example.com/wiki/freertos/"/>
    <id>http://example.com/wiki/freertos/</id>
    <published>2025-04-07T00:05:54.000Z</published>
    <updated>2025-04-14T00:58:53.532Z</updated>
    
    <content type="html"><![CDATA[<p>学习 freertos kernel layer 内容，运行原理</p><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="FreeRTOS-架构总览"><a href="#FreeRTOS-架构总览" class="headerlink" title="FreeRTOS 架构总览"></a>FreeRTOS 架构总览</h3><table><thead><tr><th>层级</th><th>描述</th></tr></thead><tbody><tr><td><strong>应用层 (Application Layer)</strong></td><td>用户自定义任务、回调函数，调用 FreeRTOS API</td></tr><tr><td><strong>内核层 (Kernel Layer)</strong></td><td>任务管理、调度器、内存管理、任务间通信、软件定时器等核心功能</td></tr><tr><td><strong>硬件抽象层 (Porting Layer)</strong></td><td>硬件相关实现：上下文切换、Tick 中断处理</td></tr><tr><td><strong>硬件层 (Hardware Layer)</strong></td><td>CPU、定时器、中断控制器、外设等硬件资源</td></tr></tbody></table><p><strong>kernel layer</strong></p><table><thead><tr><th>模块</th><th>主要功能</th><th>对应file</th></tr></thead><tbody><tr><td>任务管理 (Task Management)</td><td>任务创建、删除、挂起、恢复，任务优先级，TCB（任务控制块）</td><td>tasks.c, tasks.h</td></tr><tr><td>调度器 (Scheduler)</td><td>抢占式调度、时间片轮转调度</td><td>tasks.c, tasks.h</td></tr><tr><td>时间管理 (Time Management)</td><td>Tick 定时器，任务延时 vTaskDelay()、vTaskDelayUntil()</td><td>timers.c, timers.h, tasks.c</td></tr><tr><td>任务间通信 (Inter-task Communication)</td><td>队列（Queue）、信号量（Semaphore）、互斥锁（Mutex）、事件组（Event Group）</td><td>queue.c, queue.h, semphr.c, semphr.h, event_groups.c, event_groups.h</td></tr><tr><td>内存管理 (Memory Management)</td><td>Heap_1 ~ Heap_5，动态&#x2F;静态内存分配</td><td>heap_1.c, heap_2.c, heap_3.c, heap_4.c, heap_5.c</td></tr><tr><td>软件定时器 (Software Timer)</td><td>定时器服务任务，定时器回调处理</td><td>timers.c, timers.h</td></tr></tbody></table><br/><hr><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><table><thead><tr><th>数据类型&#x2F;元素</th><th>命名规则说明</th><th>示例</th></tr></thead><tbody><tr><td><strong>char 类型</strong></td><td>以 <code>c</code> 为字首</td><td><code>cVarName</code></td></tr><tr><td><strong>short 类型</strong></td><td>以 <code>s</code> 为字首</td><td><code>sVarName</code></td></tr><tr><td><strong>long 类型</strong></td><td>以 <code>l</code> 为字首</td><td><code>lVarName</code></td></tr><tr><td><strong>float 类型</strong></td><td>以 <code>f</code> 为字首</td><td><code>fVarName</code></td></tr><tr><td><strong>double 类型</strong></td><td>以 <code>d</code> 为字首</td><td><code>dVarName</code></td></tr><tr><td><strong>Enum 类型</strong></td><td>以 <code>e</code> 为字首</td><td><code>eVarName</code></td></tr><tr><td><strong>portBASE_TYPE 或 struct</strong></td><td>以 <code>x</code> 为字首</td><td><code>xVarName</code></td></tr><tr><td><strong>pointer 变量</strong></td><td>对应类型前加 <code>p</code> 前缀</td><td><code>psVarName</code>（short 类型的 pointer）</td></tr><tr><td><strong>unsigned 类型</strong></td><td>对应类型前加 <code>u</code> 前缀</td><td><code>usVarName</code>（unsigned short 类型）</td></tr><tr><td><strong>函数</strong></td><td>以回传值类型和所在文件名为开头（prefix）</td><td><code>vTaskPriority()</code>（task.c 中的 void 类型函数）</td></tr><tr><td><strong>回传值为 portBASE_TYPE 的函数</strong></td><td>以回传值类型和文件名为开头</td><td><code>xQueueReceive()</code>（queue.c 中的 portBASE_TYPE 类型函数）</td></tr><tr><td><strong>私有函数（仅限文件内使用）</strong></td><td>以 <code>prv</code> 为开头（private function）</td><td><code>prvPrivateFunction()</code></td></tr><tr><td><strong>宏定义</strong></td><td>宏名称为大写字母，定义文件名的小写字母作为前缀</td><td><code>portMAX_DELAY</code>（portable.h）</td></tr><tr><td><strong>配置宏定义</strong></td><td><strong>宏定义名称前加文件名的小写字母作为前缀</strong></td><td><code>configUSE_PREEMPTION</code>（FreeRTOSConfig.h）</td></tr></tbody></table><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p><strong>举例典型的 create task flow</strong></p><p>创建 task 1&#x2F;2 , 各有一个 msg queue ， 使用 switch 方式处理 task 从 msg queue 里收到的不同 msg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义事件类型（消息类型）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    MSG_TASK1 = <span class="number">1</span>,</span><br><span class="line">    MSG_TASK2,</span><br><span class="line">    MSG_STOP</span><br><span class="line">&#125; MessageType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息结构体，包含消息类型和其他必要的数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    MessageType messageType;</span><br><span class="line">    <span class="type">void</span> *data;  <span class="comment">// 可以存储额外的数据</span></span><br><span class="line">&#125; EventMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1的事件队列句柄</span></span><br><span class="line">QueueHandle_t xEventQueue1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务2的事件队列句柄</span></span><br><span class="line">QueueHandle_t xEventQueue2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask1</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    EventMessage receivedMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从任务1的队列接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (xQueueReceive(xEventQueue1, &amp;receivedMessage, portMAX_DELAY) == pdPASS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (receivedMessage.messageType == MSG_TASK1) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;任务1：执行特定操作\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (receivedMessage.messageType == MSG_STOP) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;任务1：停止任务\n&quot;</span>);</span><br><span class="line">                vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">// 删除当前任务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务2的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTask2</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    EventMessage receivedMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从任务2的队列接收消息</span></span><br><span class="line">        <span class="keyword">if</span> (xQueueReceive(xEventQueue2, &amp;receivedMessage, portMAX_DELAY) == pdPASS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (receivedMessage.messageType == MSG_TASK2) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;任务2：执行特定操作\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (receivedMessage.messageType == MSG_STOP) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;任务2：停止任务\n&quot;</span>);</span><br><span class="line">                vTaskDelete(<span class="literal">NULL</span>);  <span class="comment">// 删除当前任务</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化任务和队列的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initTasks</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建任务1的事件队列</span></span><br><span class="line">    xEventQueue1 = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(EventMessage));</span><br><span class="line">    <span class="keyword">if</span> (xEventQueue1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务1的事件队列创建失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建任务2的事件队列</span></span><br><span class="line">    xEventQueue2 = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(EventMessage));</span><br><span class="line">    <span class="keyword">if</span> (xEventQueue2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务2的事件队列创建失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建任务1</span></span><br><span class="line">    <span class="keyword">if</span> (xTaskCreate(vTask1, <span class="string">&quot;Task1&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, tskIDLE_PRIORITY + <span class="number">1</span>, <span class="literal">NULL</span>) != pdPASS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务1创建失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建任务2</span></span><br><span class="line">    <span class="keyword">if</span> (xTaskCreate(vTask2, <span class="string">&quot;Task2&quot;</span>, <span class="number">128</span>, <span class="literal">NULL</span>, tskIDLE_PRIORITY + <span class="number">2</span>, <span class="literal">NULL</span>) != pdPASS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务2创建失败！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化任务和队列</span></span><br><span class="line">    initTasks();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动调度器</span></span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调度器启动失败，通常会回到这个地方，发生在内存不足时</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调度器启动失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 永远不应到达这里</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>task 状态及切换</strong></p><center><img src="/../images/freertos/1-task_status.png" width="400px"></center><table><thead><tr><th><strong>当前状态</strong></th><th><strong>事件&#x2F;操作</strong></th><th><strong>下一个状态</strong></th></tr></thead><tbody><tr><td>Running</td><td>时间片用尽 &#x2F; 更高优先级 task awake</td><td>Ready</td></tr><tr><td>Running</td><td>发生阻塞事件</td><td>Blocked</td></tr><tr><td>Running</td><td>显式挂起</td><td>Suspended</td></tr><tr><td>Ready</td><td>被调度器选择</td><td>Running</td></tr><tr><td>Ready</td><td>抢占低优先级任务</td><td>Running</td></tr><tr><td>Blocked</td><td>阻塞事件发生</td><td>Ready</td></tr><tr><td>Blocked</td><td>超时</td><td>Ready</td></tr><tr><td>Suspended</td><td>被显式恢复</td><td>Ready</td></tr></tbody></table><table><thead><tr><th><strong>状态</strong></th><th><strong>定义</strong></th><th><strong>特点</strong></th><th><strong>状态切换</strong></th></tr></thead><tbody><tr><td><strong>Running</strong></td><td>当任务正在实际执行时，任务处于 Running 状态。此时任务正在占用处理器资源。</td><td>- <strong>单核处理器</strong>：在单核处理器上，任何时刻只有一个任务能够处于 Running 状态。<br />- <strong>多核处理器</strong>：多个任务可以在不同核心上处于 Running 状态，但每个核心只能执行一个任务。</td><td>- 当任务的<strong>时间片用尽</strong>或<strong>更高优先级的任务</strong>被唤醒时，当前任务将会被切换到 Ready 状态。<br />- 如果任务发生阻塞或挂起，任务将退出 Running 状态并转为相应的状态。</td></tr><tr><td><strong>Ready</strong></td><td>当任务随时可以执行（即不在 Blocked 或 Suspended 状态中）。</td><td>- 任务处于 Ready 状态时，它并不会立即执行，而是等待调度器选择它。<br />- 只有优先级最高的任务才会被调度器选择进入 Running 状态。<br />- 或多个相同优先级任务的 RR 切换</td><td>- 当有更高优先级的任务进入 Ready 状态，Running 任务会被中断并切换到 Ready 状态。<br />- 如果任务的优先级足够高并且没有其他任务正在执行，任务会被调度进入 Running 状态，抢占其他任务。</td></tr><tr><td><strong>Blocked</strong></td><td>任务在等待某个事件发生时会进入 Blocked 状态。这些事件通常是临时的（如延迟），或者是外部事件（如等待队列、信号量、事件组等）。</td><td>- 任务会在发生阻塞条件（如调用 vTaskDelay()、等待队列、信号量等）时进入 Blocked 状态，直到事件发生，任务才会被唤醒。<br />- 阻塞状态通常会设置一个超时时间，任务在超时后也会被唤醒。<br />- 任务在 Blocked 状态下不占用 CPU 时间。</td><td>- 一旦事件发生（如超时、信号量释放、队列接收到数据等），任务会从 Blocked 状态切换到 Ready 状态，等待调度器安排执行。</td></tr><tr><td><strong>Suspended</strong></td><td>任务可以被显式地挂起进入 Suspended 状态。挂起的任务不会自动恢复执行，必须由程序显式地恢复。</td><td>- 任务进入 Suspended 状态后不会占用 CPU 时间，调度器也不会选择该任务执行。<br />- 任务通过调用 vTaskSuspend() 进入该状态，恢复通过 xTaskResume() 实现。<br />- 与 Blocked 状态不同，Suspended 状态没有超时机制。</td><td>- 任务通过 vTaskSuspend() 进入 Suspended 状态，直到显式通过 xTaskResume() 恢复，任务才会转到 Ready 状态，等待调度器调度执行。</td></tr></tbody></table><table><thead><tr><th><strong>state</strong></th><th><strong>global var</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>Running</strong></td><td>TCB_t * volatile pxCurrentTCB</td><td>因为运行态的任务永远只有一个，所以使用 pxCurrentTCB 指向当前任务的 TCB。</td></tr><tr><td><strong>Ready</strong></td><td>static List_t pxReadyTasksLists[configMAX_PRIORITIES]</td><td>该数组存储每个优先级的就绪任务队列。configMAX_PRIORITIES 对应最大的任务优先级，任务按优先级被添加到对应链表中。</td></tr><tr><td></td><td>static List_t xPendingReadyList</td><td>当调度器被挂起时，待唤醒的任务首先添加到此链表，恢复调度器后再将其转移到就绪链表中。此链表用于暂存调度器被挂起时的就绪任务。</td></tr><tr><td><strong>Blocked</strong></td><td>static List_t xDelayedTaskList1</td><td>当任务在<strong>等待某个事件</strong>或者<strong>主动delay</strong>的时候，就会被添加到延迟链表中，并根据即将溢出的时间（链表中的值为 xConstTickCount + xTicksToWait）先后顺序排列</td></tr><tr><td></td><td>static List_t xDelayedTaskList2</td><td>当该延迟时间溢出（xConstTickCount + xTicksToWait 小于 xConstTickCount）时就会被添加到延迟溢出链表，当系统时间溢出后，调用 taskSWITCH_DELAYED_LISTS 将链表pxDelayedTaskList 和 pxOverflowDelayedTaskList 交换</td></tr><tr><td></td><td>static List_t * volatile pxDelayedTaskList</td><td>用于指向当前的延迟任务链表，通常是 xDelayedTaskList1。</td></tr><tr><td></td><td>static List_t * volatile pxOverflowDelayedTaskList</td><td>当系统时间溢出后，延迟时间溢出的任务会被转移到此链表。</td></tr><tr><td><strong>Suspend</strong></td><td>static List_t xSuspendedTaskList</td><td>存储被挂起的任务，这些任务不再参与调度，直到被显式恢复。</td></tr></tbody></table><h3 id="task-creation"><a href="#task-creation" class="headerlink" title="task creation"></a>task creation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 3 related api, 2 create, 1 delete</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pvTaskCode,        <span class="comment">// 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,        <span class="comment">// 任务名称</span></span></span><br><span class="line"><span class="params">    <span class="type">uint16_t</span> usStackDepth,            <span class="comment">// 任务栈大小（单位：字）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *pvParameters,               <span class="comment">// 传递给任务的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,           <span class="comment">// 任务优先级</span></span></span><br><span class="line"><span class="params">    TaskHandle_t *pxCreatedTask       <span class="comment">// 返回任务句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pvTaskCode,        <span class="comment">// 任务函数</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,        <span class="comment">// 任务名称</span></span></span><br><span class="line"><span class="params">    <span class="type">uint16_t</span> usStackDepth,            <span class="comment">// 任务栈大小（单位：字）</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> *pvParameters,               <span class="comment">// 传递给任务的参数</span></span></span><br><span class="line"><span class="params">    UBaseType_t uxPriority,           <span class="comment">// 任务优先级</span></span></span><br><span class="line"><span class="params">    StackType_t *pxStackBuffer,       <span class="comment">// 用户提供的栈空间</span></span></span><br><span class="line"><span class="params">    StaticTask_t *pxTaskBuffer        <span class="comment">// 用户提供的任务控制块（TCB）</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure><p><strong>xTaskCreate xTaskCreateStatic 最主要的区别是 task memory 的来源，tcb + stack 来源于用户分配 &#x2F; 系统分配</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>xTaskCreate()</strong></th><th><strong>xTaskCreateStatic()</strong></th></tr></thead><tbody><tr><td><strong>内存分配方式</strong></td><td>动态分配内存，通过 FreeRTOS 内部的堆管理器进行分配。</td><td>静态分配内存，使用用户提供的内存块，不依赖动态内存管理。</td></tr><tr><td><strong>任务控制块（TCB）</strong></td><td>动态分配一个任务控制块（TCB）和任务栈空间。</td><td>用户提供自己的任务控制块（TCB）和栈空间。</td></tr><tr><td><strong>使用内存</strong></td><td>依赖于 pvPortMalloc()（默认的堆分配器）。</td><td>直接使用静态内存，避免了堆内存分配和回收的开销。</td></tr><tr><td><strong>任务栈</strong></td><td>由 xTaskCreate() 内部创建并分配栈空间。</td><td>用户提供栈空间，通过 xTaskCreateStatic() 指定栈空间。</td></tr><tr><td><strong>调试和优化</strong></td><td>动态内存分配可能会引入堆碎片和不确定的内存问题。</td><td>静态内存分配更可靠，适用于嵌入式系统，避免了堆碎片问题。</td></tr><tr><td><strong>优点</strong></td><td>简单易用，适用于大多数应用。</td><td>无堆内存依赖，更高效，适用于内存受限的系统或不希望使用堆的情况。</td></tr></tbody></table><hr><h3 id="xTaskCreate-详细trace"><a href="#xTaskCreate-详细trace" class="headerlink" title="xTaskCreate 详细trace"></a>xTaskCreate 详细trace</h3><h4 id="step1-prvCreateTask"><a href="#step1-prvCreateTask" class="headerlink" title="step1 - prvCreateTask"></a>step1 - prvCreateTask</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只列举了必要的 tcb item</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> StackType_t *pxTopOfStack;   <span class="comment">/* 栈顶指针（指向栈顶） */</span></span><br><span class="line">    StackType_t *pxEndOfStack</span><br><span class="line">    ListItem_t xStateListItem;            <span class="comment">/* 任务就绪/挂起链表中的元素（用于任务调度） */</span></span><br><span class="line">    ListItem_t xEventListItem;            <span class="comment">/* 事件等待链表元素 */</span></span><br><span class="line">    UBaseType_t uxPriority;               <span class="comment">/* 任务的优先级 */</span></span><br><span class="line">    StackType_t *pxStack;                 <span class="comment">/* 任务栈的起始地址 */</span></span><br><span class="line">    <span class="type">char</span> pcTaskName[ configMAX_TASK_NAME_LEN ]; <span class="comment">/* 任务名称 */</span></span><br><span class="line">    <span class="comment">// ... 其他与任务相关的状态信息 ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><ol><li>申请 <code>TCB mem</code>, 并初始化为 0</li></ol></li><li><ol start="2"><li>申请 <code>stack mem</code>, 如果 1 success</li></ol></li><li><ol start="3"><li>prvInitialiseNewTask <code>初始化 tcb + stack</code>, 初始化tcb 中的item，将stack 初始成刚从中断回归的样子（reg 排放位置不同的指令集不同）</li></ol></li></ul><br/><p><strong>prvInitialiseNewTask</strong> </p><ul><li><ol><li>将 stack mem 填充为规律的字符串， 如 0xa5U</li></ol></li><li><ol start="2"><li>初始化 tcb pxTopOfStack &#x2F; tcb pxEndOfStack</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   pxTopOfStack = pxNewTCB-&gt;pxStack; <span class="comment">// 获取栈起始地址</span></span><br><span class="line"><span class="comment">// 对齐到目标字节边界（如 4/8 字节对齐），避免硬件访问异常</span></span><br><span class="line">   pxTopOfStack = ( StackType_t * ) ( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) + portBYTE_ALIGNMENT_MASK ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/* Check the alignment of the calculated top of stack is correct. 断言验证对齐成功*/</span></span><br><span class="line">   configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == <span class="number">0U</span> ) );</span><br><span class="line">  </span><br><span class="line">   <span class="comment">/* The other extreme of the stack space is required if stack checking is</span></span><br><span class="line"><span class="comment">    * performed. 保存栈空间的“顶端”地址，给栈溢出检测或栈指针初始化使用*/</span></span><br><span class="line">   pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( uxStackDepth - ( configSTACK_DEPTH_TYPE ) <span class="number">1</span> );</span><br></pre></td></tr></table></figure><p><code>举例 ： (pxTopOfStack + portBYTE_ALIGNMENT_MASK) = 0x10003 + 0x07 = 0x1000A , 然后与 ~(0x07) = 0x1000A &amp; 0xFFFFFFF8 = 0x10008</code></p></li><li><ol start="3"><li>赋值 tcb pcTaskName</li></ol></li><li><ol start="4"><li><p>规范化 uxPriority 使&lt; max priority , 并赋值 tcb uxPriority</p><table><thead><tr><th>uxPriority (任务优先级)**</th><th><strong>item value &#x3D; configMAX_PRIORITIES - uxPriority</strong></th></tr></thead><tbody><tr><td>5</td><td>10 - 5 &#x3D; 5</td></tr><tr><td>8</td><td>10 - 8 &#x3D; 2 (值更小，排更前面)</td></tr></tbody></table></li></ol></li><li><ol start="5"><li>init list item ; 设定 list item owner 为 tcb, 通过 listSET_LIST_ITEM_OWNER; 设定 evt list item value 为 priority（用来之后按优先级处理evt）; <code>xStateListItem ：用于任务所在的调度器状态队列，比如就绪队列、挂起队列、延时队列。xEventListItem ：用于事件队列，比如信号量等待队列，事件组等待队列。</code></li></ol></li><li><ol start="6"><li>init stack ~ pxPortInitialiseStack (不同的assemble code 使用的不同的恢复现场的方式，所以这里的实现也不同)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">StackType_t *<span class="title function_">pxPortInitialiseStack</span><span class="params">( StackType_t *pxTopOfStack, TaskFunction_t pxTaskCode, <span class="type">void</span> *pvParameters )</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">/* 假设栈是从高地址开始向下增长 */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 设置任务栈的内容 */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 初始化栈的内容，模拟从中断返回的情况 */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* mstatus 寄存器: 设置为用户模式 */</span></span><br><span class="line">      pxTopOfStack--; <span class="comment">/* mstatus 的位置 */</span></span><br><span class="line">      *pxTopOfStack = ( StackType_t ) <span class="number">0x00000000U</span>;  <span class="comment">/* 设置为用户模式，具体值视情况而定 */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* pc 寄存器：程序计数器，任务的入口地址 pxTaskCode */</span></span><br><span class="line">      pxTopOfStack--; <span class="comment">/* pc 寄存器的位置 */</span></span><br><span class="line">      *pxTopOfStack = ( StackType_t ) pxTaskCode;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 保存其它寄存器内容，设为默认值（0 或者特定初始化值） */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">          pxTopOfStack--; <span class="comment">/* x0 ~ x31 寄存器的栈位置 */</span></span><br><span class="line">          *pxTopOfStack = <span class="number">0</span>;  <span class="comment">/* 默认为 0 */</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 保存函数参数（pvParameters），即传递给任务函数的参数 */</span></span><br><span class="line">      pxTopOfStack--; <span class="comment">/* x0 寄存器的位置 */</span></span><br><span class="line">      *pxTopOfStack = ( StackType_t ) pvParameters;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 中断标志寄存器 mtvec, mcause, mepc 通常在调度时恢复，这里可以初始化为零 */</span></span><br><span class="line">      <span class="comment">/* 这在实际中一般不需要，因为 FreeRTOS 主要是模拟中断返回来进行任务切换 */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 返回任务栈的顶部指针，栈已经初始化 */</span></span><br><span class="line">      <span class="keyword">return</span> pxTopOfStack;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* stack 初始化后的长相，下次切换到此task后可以直接从这个现场开始run</span></span><br><span class="line"><span class="comment">  +---------------------------+ &lt;- 栈顶 (pxTopOfStack)</span></span><br><span class="line"><span class="comment">  |       mstatus             | &lt;- 任务的 mstatus 寄存器 (用户模式标志等)</span></span><br><span class="line"><span class="comment">  +---------------------------+</span></span><br><span class="line"><span class="comment">  |       pc (Task Code)      | &lt;- 程序计数器 (指向任务入口地址)</span></span><br><span class="line"><span class="comment">  +---------------------------+</span></span><br><span class="line"><span class="comment">  |       x31                 | &lt;- 寄存器 x31 (初始化为 0)</span></span><br><span class="line"><span class="comment">  +---------------------------+</span></span><br><span class="line"><span class="comment">  |       x30                 | &lt;- 寄存器 x30 (初始化为 0)</span></span><br><span class="line"><span class="comment">  +---------------------------+</span></span><br><span class="line"><span class="comment">  |         ...                | &lt;- 其他通用寄存器 x29, x28, ..., x1 (初始化为 0)</span></span><br><span class="line"><span class="comment">  +---------------------------+</span></span><br><span class="line"><span class="comment">  |       x0                  | &lt;- 寄存器 x0 (初始化为 0)</span></span><br><span class="line"><span class="comment">  +---------------------------+</span></span><br><span class="line"><span class="comment">  |       pvParameters        | &lt;- 任务的参数 pvParameters</span></span><br><span class="line"><span class="comment">  +---------------------------+ &lt;- 栈底 (pxStack)</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="step2-prvAddNewTaskToReadyList"><a href="#step2-prvAddNewTaskToReadyList" class="headerlink" title="step2 - prvAddNewTaskToReadyList"></a>step2 - prvAddNewTaskToReadyList</h4><p>ready list 结构如下图，是一个数组，数组的每个item 挂了一串同优先级的 tcb-&gt;state_item</p><center><img src="/../images/freertos/2-ready_list_struct.png" width="500px"></center><center><img src="/../images/freertos/3-ready_list_item.png" width="500px"></center><p>操作了很多 global var， 所以func 基本都在屏蔽中断中run</p><ul><li>1.<code>uxCurrentNumberOfTasks + 1</code>, 如 uxCurrentNumberOfTasks &#x3D; 1, 说明是 first tcb， 要init task list,</li><li>2.<code>pxCurrentTCB</code>,  如当前没 taks run 则 current tcb &#x3D; tcb; 否则有其他 task run 则比较优先级比的过就切(在<code>xSchedulerRunning = false</code> 的状况下即初始化 tasks 时候才可以这样硬切 tcb)</li><li>3.<code>uxTaskNumber + 1</code>, 记录所有运行过的task num</li><li>4.<code>pxReadyTasksLists</code>,</li><li>5.<code>uxTopReadyPriority</code>, 记录当前准备执行的任务的最高优先级，帮助调度器快速判断下一个应当运行的任务</li></ul><p><strong>task flow</strong></p><ul><li>1.关中断</li><li>2.uxCurrentNumberOfTasks++</li><li>3.pxCurrentTCB &#x3D;&#x3D; NULL 则 current tcb &#x3D; task tcb, 同时如果 uxCurrentNumberOfTasks &#x3D;&#x3D;  1 则init task list</li><li>4.pxCurrentTCB !&#x3D; NULL &amp;&amp; xSchedulerRunning &#x3D;&#x3D; pdFALSE 则直接切task, current tcb &#x3D; task tcb</li><li>5.uxTaskNumber++</li><li>6.prvAddTaskToReadyList( pxNewTCB ) ~ refresh <code>uxTopReadyPriority</code>, 并把 tcb-&gt;state_item 插入到 ready_list[tcb-&gt;priority] 的 list 末尾</li><li>7.开中断</li><li>8.xSchedulerRunning !&#x3D; pdFALSE，调用 portYield 切换task，新task priority 优先级可能higher</li></ul><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="ref-link"><a href="#ref-link" class="headerlink" title="ref link"></a>ref link</h3><p><a href="https://wiki.csie.ncku.edu.tw/embedded/freertos">https://wiki.csie.ncku.edu.tw/embedded/freertos</a><br><a href="https://www.freertos.org/">https://www.freertos.org/</a><br><a href="https://www.cnblogs.com/zhn11212023/p/13115799.html">https://www.cnblogs.com/zhn11212023/p/13115799.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习 freertos kernel layer 内容，运行原理&lt;/p&gt;
&lt;hr style=&quot;border: 2px solid #000; margin: 20px 0;&quot;&gt;

&lt;h3 id=&quot;FreeRTOS-架构总览&quot;&gt;&lt;a href=&quot;#FreeRTOS-架构总览</summary>
      
    
    
    
    <category term="freeRTOS" scheme="http://example.com/categories/freeRTOS/"/>
    
    
    <category term="freeRTOS" scheme="http://example.com/tags/freeRTOS/"/>
    
  </entry>
  
  <entry>
    <title>802-15-4-phy_related</title>
    <link href="http://example.com/wiki/802-15-4-phy-related/"/>
    <id>http://example.com/wiki/802-15-4-phy-related/</id>
    <published>2025-03-31T00:14:40.000Z</published>
    <updated>2025-04-02T00:54:44.110Z</updated>
    
    <content type="html"><![CDATA[<p>简单学习了 802.15.4(2015) phy layer 。</p><hr style="border: 2px solid #000; margin: 20px 0;"><center><img src="/../images/802-15-4-mac-frm/12_phy_services.png" width="400px"></center><h4 id="PHY-services"><a href="#PHY-services" class="headerlink" title="PHY services"></a>PHY services</h4><p><strong>PHY（物理层）</strong> 通过 <strong>RF 固件</strong> 和 <strong>RF 硬件</strong>，在 <strong>MAC 子层</strong> 与 <strong>物理无线信道</strong> 之间提供接口。<br><br/></p><p><strong>PHY 组件</strong><br>PHY 概念上包含一个管理实体 <strong>PLME（PHY 层管理实体）</strong>，其职责包括：</p><ul><li>提供 <strong>层管理服务接口</strong>，用于调用层管理功能。</li><li>维护 <strong>PHY 层 PAN 信息库（PHY PIB）</strong>，存储 PHY 相关的管理对象。</li></ul><br/><p><strong>PHY 服务接口</strong><br>PHY 提供 <strong>两类服务</strong>，通过 <strong>两个 SAP（服务访问点）</strong> 访问：</p><ol><li><strong>PHY 数据服务</strong> —— 通过 <strong>PHY 数据 SAP（PD-SAP）</strong> 访问。</li><li><strong>PHY 管理服务</strong> —— 通过 <strong>PLME-SAP</strong> 访问。</li></ol><blockquote><p><strong>注意</strong>：本标准未定义 <strong>PD-SAP 和 PLME-SAP</strong>，因为典型实现中不会直接暴露它们。</p><br/></blockquote><p><strong>PHY PIB 访问</strong></p><ul><li><strong>PHY PIB 属性</strong> 通过 <strong>MLME-SAP</strong> 访问，使用：<ul><li><strong>MLME-GET</strong> 读取属性</li><li><strong>MLME-SET</strong> 设置属性</li></ul><br/></li></ul><p><strong>常量与属性</strong></p><ul><li><strong>PHY 维护的常量</strong>：<ul><li>以 <strong>“a”</strong> 作为前缀，例如 <strong>aMaxPhyPacketSize</strong>（见表 11-1）。</li></ul></li><li><strong>PHY 维护的属性</strong>：<ul><li>以 <strong>“phy”</strong> 作为前缀，例如 <strong>phyCurrentChannel</strong>（见表 11-2）。</li><li><strong>特定 PHY 属性</strong>：<ul><li>以 <strong>“phyHrpUwb”</strong> 为前缀的属性（如 <strong>phyHrpUwbDataRatesSupported</strong>）<strong>仅适用于 HRP UWB PHY</strong>，其他 PHY 不使用这些属性。</li></ul></li></ul></li></ul><hr style="border: 2px solid #000; margin: 20px 0;"><h4 id="通用要求与定义"><a href="#通用要求与定义" class="headerlink" title="通用要求与定义"></a>通用要求与定义</h4><p>除非另有规定，所有 <strong>PHY 层</strong> 使用 <strong>2 字节（octet）</strong> 的 <strong>FCS（帧校验序列）</strong>。</p><p><strong>PHY 层的主要职责</strong><br>PHY 层负责以下任务：</p><ul><li><strong>激活和关闭</strong> 无线收发器</li><li><strong>能量检测（ED）</strong>：检测当前信道的能量水平</li><li><strong>链路质量指示（LQI）</strong>：评估接收数据包的质量</li><li><strong>清除信道评估（CCA）</strong>：用于 <strong>CSMA-CA（载波侦听多址接入-冲突避免）</strong></li><li><strong>信道频率选择</strong></li><li><strong>数据传输与接收</strong></li><li><strong>精准测距（Precision Ranging）</strong>：用于 <strong>超宽带（UWB）PHY</strong></li></ul><hr style="border: 2px solid #000; margin: 20px 0;"><h4 id="不同-PHY-类型的-PDU-形式是否不同？"><a href="#不同-PHY-类型的-PDU-形式是否不同？" class="headerlink" title="不同 PHY 类型的 PDU 形式是否不同？"></a>不同 PHY 类型的 PDU 形式是否不同？</h4><p>不同的 PHY（物理层）类型的 PDU（协议数据单元，Protocol Data Unit）格式是不同的。IEEE 802.15.4 标准定义了多种 PHY，每种 PHY 的 <strong>帧结构、调制方式、编码方式和字段布局</strong> 都可能有所不同。</p><hr><p><strong>1. PDU 的基本组成</strong><br>通常，PHY PDU 由以下几个部分组成：</p><ul><li><strong>SHR（同步头，Synchronization Header）：</strong> 用于接收机同步。</li><li><strong>PHR（PHY 头部，PHY Header）：</strong> 指示帧的长度和格式。</li><li><strong>Payload（有效载荷）：</strong> MAC 层的 MPDU（MAC Protocol Data Unit）。</li><li><strong>FCS（帧校验序列，Frame Check Sequence）：</strong> 用于错误检测。</li></ul><p>不同 PHY 类型可能会在这些字段的长度、格式、调制编码等方面有所不同。</p><hr><p><strong>2. 不同 PHY 类型的 PDU 差异</strong></p><table><thead><tr><th><strong>PHY 类型</strong></th><th><strong>调制方式</strong></th><th><strong>PDU 主要差异</strong></th></tr></thead><tbody><tr><td><strong>O-QPSK PHY</strong></td><td>Offset-QPSK (DSSS)</td><td>采用 <strong>6 字节 SHR</strong>，2 字节 PHR，支持变长帧</td></tr><tr><td><strong>BPSK PHY</strong></td><td>BPSK (DSSS)</td><td>采用 <strong>6 字节 SHR</strong>，2 字节 PHR，低速率但抗干扰强</td></tr><tr><td><strong>ASK PHY</strong></td><td>ASK&#x2F;BPSK (PSSS)</td><td>支持更灵活的数据速率</td></tr><tr><td><strong>CSS PHY</strong></td><td>Chirp Spread Spectrum</td><td><strong>SHR、PHR 长度不同</strong>，适用于远距离通信</td></tr><tr><td><strong>HRP UWB PHY</strong></td><td>BPM + BPSK</td><td><strong>短 SHR（4-8 字节）</strong>，FCS 可变</td></tr><tr><td><strong>SUN FSK PHY</strong></td><td>FSK</td><td>采用 <strong>可变长度 PDU</strong>，PHR 具有更多控制比特</td></tr><tr><td><strong>SUN OFDM PHY</strong></td><td>OFDM</td><td><strong>带有特殊 PHR 编码</strong>，适用于高速传输</td></tr></tbody></table><hr><p><strong>3. 主要区别点</strong></p><ul><li><strong>前导码（SHR）</strong> 长度不同，用于不同同步需求。</li><li><strong>PHY 头（PHR）</strong> 格式不同，决定帧长、调制模式等。</li><li><strong>有效载荷（Payload）</strong> 可能支持不同的最大长度。</li><li><strong>FCS 校验方式</strong>：不同 PHY 可能采用 <strong>16-bit 或 32-bit FCS</strong>。</li></ul><p>不同应用场景（如低功耗、远距离、高速率）都会影响 PHY PDU 的设计。</p><hr style="border: 2px solid #000; margin: 20px 0;"><h4 id="举例-O-QPSK-PHY"><a href="#举例-O-QPSK-PHY" class="headerlink" title="举例 O-QPSK PHY"></a>举例 O-QPSK PHY</h4><p><strong>Format of the PPDU</strong><br>PPDU &#x3D;  SHR + PHR + Phy payload<br>SHR &#x3D; Preamble + SFD<br>PHR &#x3D; Frame Length(0~6bits) + Reserved(7bit)<br>  <br/></p><p><strong>O-QPSK PHY 同步头（SHR）字段</strong> , O-QPSK（Offset Quadrature Phase Shift Keying）PHY 的同步头（SHR）用于帧同步，包含两个主要字段：</p><p><strong>Preamble 字段</strong> , 8 个符号（即 4 字节）; 预导码字段的所有比特均为二进制 <strong>0</strong> ; 用于接收端的位同步，确保接收机可以正确锁定信号。</p><p><strong>SFD（Start Frame Delimiter）字段</strong>, 表示 SHR 结束，标识数据帧的起始位置, 内容如下：</p><table><thead><tr><th>Bits</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>Value</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><hr><br/><p><strong>调制与扩频</strong><br>O-QPSK PHY 使用一种 16 进制准正交调制技术。在每个数据符号周期中，四个信息比特用于选择 16 种几乎正交的伪随机噪声（PN）序列之一进行传输。连续的数据符号的 PN 序列被串联起来，聚合的芯片序列通过偏移正交相位移键控（O-QPSK）调制到载波上。<br><br/></p><p><strong>数据速率：</strong> </p><ul><li>在 2450 MHz、915 MHz、780 MHz 或 2380 MHz 频段时，数据速率为 <strong>250 kb&#x2F;s</strong>。</li><li>在 868 MHz 频段时，数据速率为 <strong>100 kb&#x2F;s</strong>。</li></ul><center><img src="/../images/802-15-4-mac-frm/14_phy_data_rate1.png" width="400px"></center><center><img src="/../images/802-15-4-mac-frm/15_phy_data_rate2.png" width="400px"></center><br/><ul><li><strong>2450 MHz O-QPSK PHY 的支持：</strong> 在 2450 MHz 频段时，必须支持 O-QPSK PHY。</li><li><strong>2380 MHz O-QPSK PHY 的支持：</strong> 在 2380 MHz 频段时，必须支持 O-QPSK PHY。</li><li><strong>868 MHz 或 915 MHz 频段的 O-QPSK PHY：</strong> <ul><li>O-QPSK PHY 在 868 MHz 或 915 MHz 频段并非强制要求。</li><li>如果在这些频段使用 O-QPSK PHY，则该设备还必须能够使用 BPSK PHY 信号进行通信。</li></ul><br/></li></ul><p><strong>参考调制器图</strong></p><center><img src="/../images/802-15-4-mac-frm/13_phy_mod.png" width="600px"></center><br/><p><strong>bit到symbol映射</strong></p><ul><li>每个字节（octet）的 <strong>4 个最低有效位（LSBs）</strong> (b0, b1, b2, b3) 映射到一个数据符号 （下表的0～15）。</li><li><strong>4 个最高有效位（MSBs）</strong> (b4, b5, b6, b7) 映射到下一个数据符号。</li><li>PPDU 的每个字节都会按顺序通过调制和扩频处理，从 <strong>前导码（Preamble）字段</strong> 开始，直到 <strong>PSDU 的最后一个字节</strong>。</li><li>在每个字节中：<ul><li><strong>最低有效符号</strong> (b0, b1, b2, b3) 先被处理。</li><li><strong>最高有效符号</strong> (b4, b5, b6, b7) 后被处理。</li></ul></li></ul><hr><p><strong>symbol到chip映射</strong></p><ul><li>在 <strong>2450 MHz 和 2380 MHz 频段</strong>，每个数据符号映射到一个 <strong>32 芯片（chip）</strong> 的伪随机噪声（PN）序列。</li><li>这些 PN 序列通过循环移位（cyclic shifts）和&#x2F;或共轭（conjugation，即奇数索引的芯片值反转）相互关联。</li></ul><center><img src="/../images/802-15-4-mac-frm/16_phy_symbol2chip.png" width="600px"></center><hr><p><strong>O-QPSK 调制</strong></p><ul><li><strong>芯片序列调制方式：</strong><ul><li><strong>偶数索引芯片（even-indexed chips）</strong> 调制到 <strong>同相（I）载波</strong>。</li><li><strong>奇数索引芯片（odd-indexed chips）</strong> 调制到 <strong>正交（Q）载波</strong>。</li></ul></li><li><strong>不同频段的符号到芯片映射：</strong><ul><li>在 <strong>2450 MHz 和 2380 MHz 频段</strong>，每个数据符号映射到 <strong>32 芯片</strong>，因此芯片速率是 <strong>符号速率的 32 倍</strong>。</li><li>在 <strong>915 MHz、868 MHz 和 780 MHz 频段</strong>，每个数据符号映射到 <strong>16 芯片</strong>，因此芯片速率是 <strong>符号速率的 16 倍</strong>。</li></ul></li><li><strong>I 相与 Q 相的时间偏移：</strong><ul><li><strong>Q 相芯片（Q-phase chips）</strong> 相对于 <strong>I 相芯片（I-phase chips）</strong> <strong>延迟 Tc</strong>。</li><li><strong>Tc</strong> 是芯片速率的倒数，即 <strong>Tc &#x3D; 1 &#x2F; 芯片速率</strong>。</li><li><strong>图 12-6</strong> 说明了 I 相与 Q 相芯片调制的时间偏移关系。</li></ul></li></ul><center><img src="/../images/802-15-4-mac-frm/17_pyh_qi_delay.png" width="600px"></center><p><strong>Pulse shape</strong></p><center><img src="/../images/802-15-4-mac-frm/18_phy_pulse.png" width="600px"></center><hr style="border: 2px solid #000; margin: 20px 0;"><h5 id="O-QPSK-PHY-RF-requirements"><a href="#O-QPSK-PHY-RF-requirements" class="headerlink" title="O-QPSK PHY RF requirements"></a>O-QPSK PHY RF requirements</h5><p><strong>O-QPSK PHY 在以下频段内运行：</strong></p><ul><li><strong>779–787 MHz</strong></li><li><strong>868.0–868.6 MHz</strong></li><li><strong>902–928 MHz</strong></li><li><strong>2360–2400 MHz</strong></li><li><strong>2400.0–2483.5 MHz</strong></li></ul><p>其中，<strong>2400.0–2483.5 MHz 频段</strong>（即 2.4 GHz 频段）是 O-QPSK 在 IEEE 802.15.4 标准中最常用的频段，支持 <strong>250 kbps</strong> 传输速率，并且具有全球通用性。</p><hr><br/><p><strong>Transmit power spectral density (PSD) mask</strong></p><center><img src="/../images/802-15-4-mac-frm/19_phy_tx_limit.png" width="600px"></center><p><strong>符号速率</strong></p><ul><li><strong>868 MHz 频段</strong>：符号速率为 <strong>25 ksymbol&#x2F;s</strong></li><li><strong>780 MHz、915 MHz、2380 MHz、2450 MHz 频段</strong>：符号速率为 <strong>62.5 ksymbol&#x2F;s</strong></li><li><strong>速率精度</strong>：± 40 × 10⁻⁶</li></ul><p><strong>接收灵敏度</strong> </p><ul><li>在 <strong>10.1.7 规定的测试条件下</strong>，符合标准的设备应具备 <strong>-85 dBm 或更优</strong> 的接收灵敏度。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单学习了 802.15.4(2015) phy layer 。&lt;/p&gt;
&lt;hr style=&quot;border: 2px solid #000; margin: 20px 0;&quot;&gt;

&lt;center&gt;&lt;img src=&quot;/../images/802-15-4-mac-frm/</summary>
      
    
    
    
    <category term="802.15.4" scheme="http://example.com/categories/802-15-4/"/>
    
    
    <category term="802.15.4" scheme="http://example.com/tags/802-15-4/"/>
    
  </entry>
  
  <entry>
    <title>802.15.4-mac_services</title>
    <link href="http://example.com/wiki/802-15-4-mac-services/"/>
    <id>http://example.com/wiki/802-15-4-mac-services/</id>
    <published>2025-03-27T00:35:47.000Z</published>
    <updated>2025-03-28T01:01:25.072Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了 802.15.4(2015) mac layer services, 包括 genernal review mlme &#x2F; mcps &#x2F; mac constans &amp;&amp; mac pib 。</p><hr style="border: 2px solid #000; margin: 20px 0;"><center><img src="/../images/802-15-4-mac-frm/11_mac_services.png" width="400px"></center><p>MAC 层（媒体访问控制层）负责协调设备之间的无线通信，并分为两个主要部分：<br>1.MAC 层管理实体（<strong>MLME</strong>, MAC Layer Management Entity）<br>2.MAC 公共部分子层（<strong>MCPS</strong>, MAC Common Part Sublayer）</p><hr><p><strong>SAP 的概念</strong><br>在 <strong>IEEE 802.15.4</strong> 标准中，<strong>SAP（服务访问点）</strong> 是<strong>不同协议层之间的接口</strong>，用于<strong>数据传输和管理控制</strong>。<br>SAP 允许协议栈的不同层之间交换数据和命令，例如 <strong>MCPS-SAP</strong> 和 <strong>MLME-SAP</strong>。<br><br/></p><p><strong>SAP 的作用</strong><br>在协议栈中，不同层的功能不同，而 SAP 作为接口，提供标准化的交互方式，例如：</p><ul><li><strong>应用层 ↔️ 网络层</strong> 通过 <strong>NLDE-SAP（网络层数据实体 SAP）</strong> 交换数据。</li><li><strong>网络层 ↔️ MAC 层</strong> 通过 <strong>NLME-SAP（网络层管理实体 SAP）</strong> 进行管理操作。</li><li><strong>MAC 层 ↔️ 物理层</strong> 通过 <strong>PLME-SAP（物理层管理实体 SAP）</strong> 进行通信。</li></ul><br/><p><strong>802.15.4 中常见的 SAP</strong></p><table><thead><tr><th><strong>SAP 名称</strong></th><th><strong>作用</strong></th><th><strong>涉及层</strong></th></tr></thead><tbody><tr><td><strong>MCPS-SAP</strong>（MAC Common Part Sublayer Service Access Point）</td><td>处理 MAC 层<strong>数据传输</strong></td><td>MAC 层 ↔️ 上层</td></tr><tr><td><strong>MLME-SAP</strong>（MAC Layer Management Entity Service Access Point）</td><td>处理 MAC 层<strong>管理功能</strong>（如信标、关联）</td><td>MAC 层 ↔️ 上层</td></tr><tr><td><strong>PLME-SAP</strong>（Physical Layer Management Entity Service Access Point）</td><td>物理层<strong>管理</strong>（如信道设置）</td><td>物理层 ↔️ MAC 层</td></tr><tr><td><strong>PD-SAP</strong>（Physical Data Service Access Point）</td><td>物理层<strong>数据传输</strong></td><td>物理层 ↔️ MAC 层</td></tr></tbody></table><br/><p><strong>SAP 的工作方式</strong><br>SAP 主要通过以下方式进行交互： ind + resp ; req + confirm</p><ul><li><p><strong>Indication（指示）</strong>：下层通知上层某个事件发生（如收到数据）。</p></li><li><p><strong>Response（响应）</strong>：上层对某个请求的回应（如关联请求的确认）。</p></li><li><p><strong>Request（请求）</strong>：上层请求下层执行某项操作（如发送数据）。</p></li><li><p><strong>Confirm（确认）</strong>：下层反馈请求的执行结果（如数据发送成功或失败）。</p></li></ul><br/><p><strong>SAP 示例（MCPS-DATA 发送流程）</strong><br>假设一个设备要发送数据，SAP 交互流程如下：</p><ol><li><strong>上层调用</strong> <code>MCPS-DATA.request</code>，请求 MAC 层发送数据。  </li><li><strong>MAC 层处理</strong> 该请求，并通过物理层发送数据。  </li><li><strong>如果对方收到数据并回复 ACK</strong>，MAC 层生成 <code>MCPS-DATA.confirm</code> 反馈给上层，表示发送成功。  </li><li><strong>如果对方未响应</strong>，MAC 层可能会重传，最终给出 <code>MCPS-DATA.confirm</code>，通知上层发送成功或失败。</li></ol><hr style="border: 2px solid #000; margin: 20px 0;"><h4 id="MLME-primtives"><a href="#MLME-primtives" class="headerlink" title="MLME primtives"></a>MLME primtives</h4><p>MLME-SAP（MAC 层管理实体服务访问点）接口用于上层与 MAC 层之间的管理交互。它提供了一系列的 <strong>原语（primitives）</strong>，用于执行网络管理、配置以及控制操作。包括设备的加入&#x2F;退出网络、扫描、同步、参数设置、信标通知等。这些原语是 <strong>MAC MLME</strong> 的核心部分，帮助设备与网络协调工作，确保 PAN 的正常运行。</p><hr><br/><h5 id="common-情况处理-MLME-处理-higher-layer-内容时出现问题"><a href="#common-情况处理-MLME-处理-higher-layer-内容时出现问题" class="headerlink" title="common 情况处理(MLME 处理 higher layer 内容时出现问题)"></a>common 情况处理(MLME 处理 higher layer 内容时出现问题)</h5><p><strong>错误处理（Request（请求））</strong></p><ul><li>如果在 <strong>请求原语</strong> 的 <strong>发送帧安全处理</strong>（如 9.2.1 所述）中发生任何错误，<strong>MLME</strong> 会丢弃该帧，并使用相应的确认原语，返回 <strong>发送帧安全处理</strong> 中的错误。</li></ul><p><strong>错误处理（Response（响应））</strong></p><ul><li>如果在 <strong>响应原语</strong> 的 <strong>发送帧安全处理</strong>（如 9.2.1 所述）中发生任何错误，<strong>MLME</strong> 会丢弃该帧，并使用 <strong>MLME-COMM-STATUS.indication</strong> 原语，返回 <strong>发送帧安全处理</strong> 中的错误。</li></ul><p><strong>参数无效或超出范围</strong></p><ul><li><p>如果 <strong>请求原语</strong> 中的任何参数不受支持或超出范围，<strong>MAC 子层</strong> 会使用 <strong>INVALID_PARAMETER</strong> 状态值返回相应的确认原语。</p></li><li><p>如果 <strong>响应原语</strong> 中的任何参数不受支持或超出范围，<strong>MAC 子层</strong> 会使用 <strong>INVALID_PARAMETER</strong> 状态值返回 <strong>MLME-COMM-STATUS.indication</strong> 原语。</p></li></ul><p><strong>CSMA-CA 失败</strong></p><ul><li>如果由于 <strong>CSMA-CA 算法失败</strong>，<strong>MLME</strong> 无法发送 <strong>请求原语</strong> 所需的帧，<strong>MLME</strong> 会使用 <strong>CHANNEL_ACCESS_FAILURE</strong> 状态值返回相应的确认原语。</li></ul><p><strong>ACK 未收到</strong></p><ul><li>如果 <strong>MLME</strong> 成功发送 <strong>请求原语</strong> 所需的帧，但没有收到预期的确认帧，<strong>MLME</strong> 会使用 <strong>NO_ACK</strong> 状态值返回相应的确认原语。</li></ul><hr><br/><p><strong>关键MLME原语</strong></p><ol><li><strong>MLME-ASSOCIATE</strong>: 设备请求加入网络时使用此原语。包含关联请求、确认、指示和响应。设备通过该原语与 PAN 协调器建立连接。</li><li><strong>MLME-SCAN</strong>: 该原语用于启动扫描操作，寻找可用的 PAN 网络。可以进行主动扫描（发送探测请求）或被动扫描（接收信标）。</li><li><strong>MLME-SYNC</strong>: 该原语用于设备与协调器之间的同步，确保设备与网络的时序同步。</li><li><strong>MLME-START</strong>: 该原语用于协调器启动或重新启动一个 PAN，分配新的 PAN ID，并开始信标传输。</li><li><strong>MLME-BEACON-NOTIFY</strong>: 设备接收到 PAN 协调器的信标时使用此原语，通知设备信标信息，如网络同步信息和协作参数。</li><li><strong>MLME-PROMISCUOUSMODE</strong>: 该原语允许设备进入混杂模式，即设备可以接收所有频段上的数据包，而不仅仅是属于其自己 PAN 的数据包。</li><li><strong>MLME-SET 和 MLME-GET</strong>: 这两个原语用于配置和查询 MAC 层的参数，例如 PAN ID、信标周期、重试次数等。</li></ol><hr><br/><h4 id="举例MLME-ASSOCIATE-request"><a href="#举例MLME-ASSOCIATE-request" class="headerlink" title="举例MLME-ASSOCIATE.request"></a>举例MLME-ASSOCIATE.request</h4><p><code> mlme primitive 类似于 bluetooth 的 hci cmd / hci evt，去进行一些 mac layer 控制管理</code> ，在802.15.4 中都有详细的参数描述解释定义。下面举例MLME-ASSOCIATE.request：</p><p><strong>MLME-ASSOCIATE.request 原语详细解析</strong><br>在 <strong>IEEE 802.15.4</strong> 标准中，<code>MLME-ASSOCIATE.request</code> 是一个用于设备请求加入 <strong>PAN 网络</strong> 的原语。设备通过该原语向 MAC 层请求与 <strong>PAN 协调器</strong> 建立关联。</p><p><strong>MLME-ASSOCIATE.request 的参数</strong></p><p><code>MLME-ASSOCIATE.request</code> 原语包含以下主要参数：</p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>deviceAddress</strong></td><td>设备的地址，通常是设备的 MAC 地址。可以是 <strong>短地址</strong>（16位）或 <strong>扩展地址</strong>（64位）。</td></tr><tr><td><strong>capabilityInformation</strong></td><td>设备的能力信息，用来表示设备是否支持某些功能（例如，是否支持 FFD（Full Function Device）或 RFD（Reduced Function Device）等）。</td></tr><tr><td><strong>securityLevel</strong></td><td>表示安全级别，指明通信过程中使用的加密方式及密钥管理。</td></tr><tr><td><strong>pansId</strong></td><td>指定目标 PAN 的 PAN ID。设备需要指定与之关联的 PAN。</td></tr><tr><td><strong>assocDeviceAddress</strong></td><td>设备的目标关联设备的地址。设备会尝试与此地址对应的 PAN 协调器建立联系。</td></tr></tbody></table><hr><br/><p><strong>MLME-ASSOCIATE.request 的执行流程</strong></p><p>当 <strong>MLME-ASSOCIATE.request</strong> 被发出时，MAC 层会按照以下步骤执行：</p><ol><li><p><strong>参数验证</strong><br>MAC 层首先验证原语中的 <strong>参数</strong>，例如设备地址、能力信息等是否合理。如果参数无效，原语将失败。</p></li><li><p><strong>访问权限检查</strong><br>MAC 层会根据设备的类型（如 <strong>FFD</strong> 或 <strong>RFD</strong>）和能力信息，决定是否允许设备与目标 PAN 协调器建立连接。<strong>FFD</strong> 可以充当 PAN 协调器，而 <strong>RFD</strong> 只能与 <strong>FFD</strong> 设备建立连接。</p></li><li><p><strong>发送关联请求</strong><br>如果验证通过，MAC 层将构造一个 <strong>关联请求帧</strong>（Association Request Frame）。该帧包含设备的地址、能力信息等数据，然后发送到目标 <strong>PAN 协调器</strong>。</p></li><li><p><strong>等待响应</strong><br>协调器收到请求后，会通过 <strong>MLME-ASSOCIATE.response</strong> 原语向设备响应，表明关联是否成功。如果成功，设备将被分配一个 <strong>PAN 地址</strong>（如果是新的设备）。</p></li><li><p><strong>关联成功或失败</strong>  </p><ul><li>如果关联成功，MAC 层会使用 <strong>MLME-ASSOCIATE.confirm</strong> 向上层发送确认，表示设备已经成功加入网络。</li><li>如果失败，MAC 层会发送失败指示（例如，因 PAN ID 不匹配或设备能力不符合要求）。</li></ul></li></ol><hr><br/><p><strong>与 PIB（Protocol Information Base）的关系</strong></p><p>在 <strong>MLME-ASSOCIATE.request</strong> 执行时，<strong>PIB</strong>（协议信息库）中的相关参数起着重要作用。PIB 包含与设备配置和网络管理相关的所有信息，以下是几个可能影响关联过程的 PIB 项目：</p><ol><li><p><strong>macPANId</strong><br>设备将会通过 <code>MLME-ASSOCIATE.request</code> 中的 <strong>pansId</strong> 参数向目标协调器发起关联请求，PIB 中的 <code>macPANId</code> 必须与请求的 PAN ID 匹配。</p></li><li><p><strong>macShortAddress</strong> 和 <strong>macExtendedAddress</strong><br>设备的地址会通过 <strong>deviceAddress</strong> 参数传递。MAC 层会根据 PIB 中存储的设备地址信息来处理设备的身份验证与连接。</p></li><li><p><strong>macAssociationPermit</strong><br>如果 PIB 中的 <code>macAssociationPermit</code> 为 <code>FALSE</code>，即禁用关联，MAC 层会拒绝设备的关联请求。</p></li><li><p><strong>macBeaconOrder</strong><br>如果设备在扫描过程中检测到的信标符合其 <strong>macBeaconOrder</strong>（信标周期）配置，MAC 层才会继续发送关联请求。</p></li><li><p><strong>macDeviceType</strong><br>设备的类型（FFD 或 RFD）通过 <strong>capabilityInformation</strong> 参数传递。PIB 中的 <code>macDeviceType</code> 会影响设备是否能成功加入网络。</p></li></ol><hr style="border: 2px solid #000; margin: 20px 0;"><h4 id="MCPS-primtives"><a href="#MCPS-primtives" class="headerlink" title="MCPS primtives"></a>MCPS primtives</h4><p>MAC 数据服务（MAC Data Service）通过 MCPS（MAC 层数据服务）接口提供了数据传输的基本功能</p><p><strong>功能</strong></p><ul><li><strong>发送数据</strong>：用于将数据从发送方传输到接收方。数据传输可以通过 <strong>点对点通信</strong> 或 <strong>广播</strong> 进行。</li><li><strong>接收数据</strong>：MAC 层也能够处理从物理层接收到的数据包，将其传递给上层。</li><li><strong>保证数据的可靠性</strong>：MAC 层通过重新传输机制、确认机制来保证数据的传输可靠性。</li></ul><p><strong>传输类型</strong></p><ul><li><strong>数据帧</strong>：通过数据服务传输的基本单元是数据帧（Data Frame），包括数据的有效载荷、目的地址、源地址等信息。</li><li><strong>确认（ACK）帧</strong>：用于确认数据帧的接收。</li></ul><hr><br/><p><strong>MCPS 原语</strong></p><ul><li><strong>MCPS-DATA.request</strong>：请求发送数据帧。</li><li><strong>MCPS-DATA.confirm</strong>：确认数据发送的结果。</li><li><strong>MCPS-DATA.indication</strong>：通知上层接收到的数据帧。</li></ul><p><strong>Purging 操作</strong></p><ul><li><strong>MCPS-PURGE.request</strong>：请求清除数据队列中的未成功发送的数据帧。</li><li><strong>MCPS-PURGE.confirm</strong>：确认是否成功清除数据队列中的数据帧。</li></ul><hr><br/><h4 id="举例MCPS-DATA-request"><a href="#举例MCPS-DATA-request" class="headerlink" title="举例MCPS-DATA.request"></a>举例MCPS-DATA.request</h4><p>在 <strong>IEEE 802.15.4</strong> 中，<code>MCPS-DATA.request</code> 是用于请求发送数据帧的原语。<br><br/></p><p><strong>1. MCPS-DATA.request 参数解析</strong></p><p><code>MCPS-DATA.request</code> 原语的参数通常包括以下内容：</p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>dstAddr</strong></td><td>目标设备地址，通常为 <strong>短地址</strong> 或 <strong>扩展地址</strong>。可以是单播地址或广播地址。</td></tr><tr><td><strong>srcAddr</strong></td><td>源设备地址，通常为发送设备的 <strong>短地址</strong> 或 <strong>扩展地址</strong>。</td></tr><tr><td><strong>frame</strong></td><td>要发送的数据帧，其中包括数据的有效载荷、目的地址、源地址等信息。</td></tr><tr><td><strong>securityLevel</strong></td><td>数据传输的安全级别，指示是否进行加密、验证等。此字段可以影响数据发送的安全性。</td></tr><tr><td><strong>ackRequired</strong></td><td>是否要求接收方返回确认帧（ACK）。如果为 <code>true</code>，MAC 层将等待接收方的 ACK 响应。</td></tr><tr><td><strong>txOptions</strong></td><td>传输选项，可以指定数据帧发送的额外特性（例如是否为广播帧等）。</td></tr></tbody></table><br/><p><strong>2. MCPS-DATA.request 执行流程</strong><br><br/></p><p><strong>2.1 数据准备</strong></p><ul><li>当上层应用或协议栈调用 <code>MCPS-DATA.request</code> 请求发送数据时，MAC 层会进行以下准备工作：<ol><li><strong>验证请求参数</strong>：检查目标地址、源地址等字段是否有效。</li><li><strong>构建数据帧</strong>：根据请求中的 <code>frame</code> 和其他参数构建数据帧。该数据帧包括了源地址、目标地址、有效载荷、序列号等信息。</li><li><strong>检查安全性设置</strong>：根据 <code>securityLevel</code> 参数，MAC 层会决定是否进行数据加密或认证。</li></ol></li></ul><br/><p><strong>2.2 与 PIB（协议信息库）的关系</strong><br>MAC 层会查询 <strong>PIB（Protocol Information Base）</strong> 来获取与数据发送相关的配置信息。PIB 中的一些关键参数影响数据的发送过程：<br><br/></p><ol><li><strong>macPANId</strong>：用于判断数据是否属于目标 PAN。如果数据的 <code>dstAddr</code> 与 <code>macPANId</code> 不匹配，发送操作将失败。</li><li><strong>macShortAddress</strong> 和 <strong>macExtendedAddress</strong>：这些字段用于构建源地址和目标地址，特别是设备的 16 位或 64 位地址。</li><li><strong>macAckWaitDuration</strong>：控制数据帧等待 ACK 响应的时间。如果 <code>ackRequired</code> 为 <code>true</code>，MAC 层会使用该配置项来设置等待 ACK 的最大时长。</li><li><strong>macMaxFrameRetries</strong>：如果数据发送失败，MAC 层会尝试重新发送。此参数指定最大重试次数。</li><li><strong>macMaxFrameSize</strong>：控制单个数据帧的最大大小。如果数据帧超过最大帧大小，MAC 层可能会将数据进行分段。</li></ol><br/><p><strong>2.3 数据帧的发送</strong></p><ul><li><strong>物理层发送</strong>：MAC 层会将构建好的数据帧交给物理层进行发送。物理层负责将数据转换为无线信号并传输。<br/></li></ul><p><strong>2.4 确认机制</strong></p><ul><li>如果 <code>ackRequired</code> 为 <code>true</code>，MAC 层会等待接收方发送 ACK 帧作为确认。如果在指定时间内没有收到 ACK，MAC 层会根据 <strong>PIB</strong> 中的 <code>macMaxFrameRetries</code> 设置重试次数，直到成功或超出最大重试次数。<br/></li></ul><p><strong>2.5 发送确认</strong></p><ul><li>如果数据成功发送，MAC 层会通过 <strong>MCPS-DATA.confirm</strong> 向上层应用发送数据发送成功的确认。</li><li>如果发送失败（例如超时或重试次数用尽），MAC 层会通知上层失败原因。</li></ul><hr style="border: 2px solid #000; margin: 20px 0;"><h4 id="MAC-constants-PIB"><a href="#MAC-constants-PIB" class="headerlink" title="MAC constants &amp;&amp; PIB"></a>MAC constants &amp;&amp; PIB</h4><p>在 <strong>IEEE 802.15.4</strong> 标准中，MAC（Medium Access Control）层使用一些常量和 PIB（Protocol Information Base）属性来控制和配置设备的行为。常量用于设置 MAC 层操作的参数范围，而 PIB 属性则保存设备的配置和状态信息。以下是 <strong>MAC 常量</strong> 和 <strong>PIB 属性</strong> 的详细说明。</p><hr><br/><p><strong>1. MAC 常量</strong></p><p><strong>1.1 常量概述</strong><br>MAC 常量是预定义的常量值，用于指定在 MAC 层操作中使用的各种参数。例如，这些常量用于数据传输、重试次数、最大帧大小等。它们定义了 MAC 层的一些行为规范。</p><p><strong>1.2 常见的 MAC 常量</strong></p><table><thead><tr><th><strong>常量名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>MAC_MAX_FRAME_RETRIES</strong></td><td>最大帧重试次数。指定在发送数据时，MAC 层允许的最大重试次数。默认值为 <strong>3</strong>。</td></tr><tr><td><strong>MAC_ACK_WAIT_DURATION</strong></td><td>等待确认的时间（单位：符号时间），指定了设备在发送数据后，最多等待多少符号时间以接收 ACK。</td></tr><tr><td><strong>MAC_MAX_FRAME_SIZE</strong></td><td>最大数据帧大小。指定了数据帧的最大长度（以字节为单位）。</td></tr><tr><td><strong>MAC_PAN_ID</strong></td><td>PAN（Personal Area Network）ID，指定设备所属的 PAN 标识符。</td></tr><tr><td><strong>MAC_BROADCAST_ADDR</strong></td><td>广播地址。通常用于广播数据包。</td></tr><tr><td><strong>MAC_SECURITY_ENABLED</strong></td><td>安全功能启用标志。如果为 <code>true</code>，表示启用安全功能（如加密和认证）。</td></tr><tr><td><strong>MAC_FRAME_TYPE_DATA</strong></td><td>数据帧类型常量。指定该数据帧是数据传输帧。</td></tr><tr><td><strong>MAC_FRAME_TYPE_ACK</strong></td><td>确认帧类型常量。指定该数据帧是 ACK 确认帧。</td></tr></tbody></table><p><strong>1.3 常量用途</strong><br>这些常量定义了设备的行为规范，例如：</p><ul><li><strong>MAC_MAX_FRAME_RETRIES</strong> 控制最大重试次数，确保设备不会因为多次发送失败而进入无限重试状态。</li><li><strong>MAC_ACK_WAIT_DURATION</strong> 确定了设备在发送数据后等待确认的时间，这对于网络中的数据传输延迟控制至关重要。</li><li><strong>MAC_SECURITY_ENABLED</strong> 则控制设备是否使用加密和认证机制，提高数据传输的安全性。</li></ul><hr><br/><p><strong>2. PIB 属性</strong></p><p><strong>2.1 PIB 概述</strong><br>PIB（Protocol Information Base）是一个存储协议配置信息的数据库。它保存了与 MAC 层的操作相关的各种配置和状态信息。PIB 属性用于配置设备的 MAC 层行为，并在设备运行时进行修改和读取。</p><p><strong>2.2 常见的 PIB 属性</strong></p><table><thead><tr><th><strong>属性名称</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>macShortAddress</strong></td><td>设备的短地址（16 位）。用于标识设备在同一 PAN 内的唯一性。</td></tr><tr><td><strong>macExtendedAddress</strong></td><td>设备的扩展地址（64 位），在 PAN 内唯一标识设备。</td></tr><tr><td><strong>macPANId</strong></td><td>PAN 的标识符，设备所属的个人区域网络的 ID。</td></tr><tr><td><strong>macBeaconOrder</strong></td><td>信标周期的周期性参数，指示设备发射信标的频率。</td></tr><tr><td><strong>macSuperframeOrder</strong></td><td>超帧顺序，决定设备在网络中活动时使用的时间段。</td></tr><tr><td><strong>macMaxFrameRetries</strong></td><td>数据传输失败后的最大重试次数。</td></tr><tr><td><strong>macMaxCSMABackoffs</strong></td><td>在发送数据之前，设备允许的最大退避次数，用于避免碰撞。</td></tr><tr><td><strong>macSecurityMode</strong></td><td>安全模式，指示是否启用加密和认证。</td></tr><tr><td><strong>macRxOnWhenIdle</strong></td><td>设备是否在空闲时保持接收模式。如果为 <code>true</code>，设备即使在空闲时也能接收数据。</td></tr><tr><td><strong>macMaxFrameSize</strong></td><td>允许的最大数据帧大小。</td></tr><tr><td><strong>macAckWaitDuration</strong></td><td>等待确认的最大时间（符号时间单位）。</td></tr><tr><td><strong>macTransactionPersistenceTime</strong></td><td>事务持久化时间，指示在事务期间内设备可以保持数据传输状态。</td></tr></tbody></table><p><strong>2.3 PIB 属性用途</strong><br>PIB 属性用于控制和配置设备在 <strong>MAC 层</strong> 上的行为。下面是一些常见的 PIB 属性及其应用：</p><ul><li><strong>macShortAddress 和 macExtendedAddress</strong>：用于设备地址的标识。短地址通常用于快速数据传输，而扩展地址用于全局唯一的标识。</li><li><strong>macPANId</strong>：用于标识设备所属的网络。PAN ID 是设备加入网络的关键参数，确保设备可以识别网络并与其他设备进行通信。</li><li><strong>macMaxFrameRetries</strong>：控制重试次数，确保数据的可靠传输。</li><li><strong>macSecurityMode</strong>：确定是否启用安全特性（如加密和认证），保证数据的安全性。</li><li><strong>macMaxCSMABackoffs</strong>：控制发送失败后的退避次数，用于减少碰撞并提高传输效率。</li></ul><br/><p><em><strong>2.4 PIB 和 MAC 常量的关系</strong></em><br><em>许多 <strong>PIB 属性</strong> 实际上是由 <strong>MAC 常量</strong> 决定的。例如，<code>macMaxFrameRetries</code> 和 <code>MAC_MAX_FRAME_RETRIES</code> 常量是相互关联的。常量用于设置默认值，而 PIB 属性用于在运行时修改和读取设备的配置。</em></p><hr><br/><p><strong>3. PIB 属性的访问与修改</strong></p><p><strong>3.1 读取和设置 PIB 属性</strong><br>设备可以通过特定的接口来读取和修改 PIB 属性。例如，设备可以通过 <strong>MLME</strong>（MAC Layer Management Entity）接口来设置或获取 PIB 属性。</p><p><strong>示例：设置 PIB 属性</strong></p><pre><code class="language-c">MLME_SET.request &#123;  pibAttribute: macShortAddress,  pibAttributeValue: 0x1234&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;介绍了 802.15.4(2015) mac layer services, 包括 genernal review mlme &amp;#x2F; mcps &amp;#x2F; mac constans &amp;amp;&amp;amp; mac pib 。&lt;/p&gt;
&lt;hr style=&quot;border</summary>
      
    
    
    
    <category term="802.15.4" scheme="http://example.com/categories/802-15-4/"/>
    
    
    <category term="802.15.4" scheme="http://example.com/tags/802-15-4/"/>
    
  </entry>
  
  <entry>
    <title>hexo github.io image 显示异常</title>
    <link href="http://example.com/wiki/hexo-image-sync-my-solution/"/>
    <id>http://example.com/wiki/hexo-image-sync-my-solution/</id>
    <published>2025-03-25T23:53:42.000Z</published>
    <updated>2025-03-26T00:20:56.533Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 hexo 写 blog 插入图片时，大多数会使用 typora&#x2F;markdown allin one 等去 preview，此时的(preview) img path 是相对 source&#x2F;_posts&#x2F;**.md 文档的路径；而 github.io 静态页面展示图片是要使用public 为 root path 的路径引用图片；路径不match 会导致图片显示异常，网上也有很多的案例和解法，使用起来感觉始终不顺手，在这里放上我的解法。</p><hr><br>1.创建如下目录结构：blog/source/images , blog/public/images , blog/sync.py<br>2.编辑 **.md 并想要预览时，请插入类似下面的图片链接<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;&lt;img src=&quot;/../images/802-15-4-mac-frm/4_beacon_frm.png&quot; width=&quot;800px&quot;&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><br>3.完成编辑后在 blog folder 下运行 python3 sync.py add sync, 会将 source/images 下 img sync 到 public/imgs, 同时将所有 **.md 中的图片链接前加“/”转为如下，使可以在github.io上显示<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;&lt;img src=&quot;/../images/802-15-4-mac-frm/4_beacon_frm.png&quot; width=&quot;800px&quot;&gt;&lt;/center&gt;</span><br></pre></td></tr></table></figure><br>4.运行 python3 sync.py add sync 后 md preview 将无法正常显示图片，如果想重新编辑可以再运行 python3 sync.py remove 即可<br>5.我的上blog step:  python3 sync.py add sync -> hexo c -> hexo g -> hexo d<hr style="border: 2px solid #000; margin: 20px 0;">**下面附上sync.py的code，这个是请教chatgpt帮忙写的**<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>python sync_and_modify.py sync</code></td><td>仅同步 <code>source/images</code> 到 <code>public/images</code></td></tr><tr><td><code>python sync_and_modify.py add</code></td><td>仅增加 Markdown 中 <code>img src</code> 里的 <code>/</code></td></tr><tr><td><code>python sync_and_modify.py sync add</code></td><td><strong>同步图片 + 增加 <code>/</code></strong></td></tr><tr><td><code>python sync_and_modify.py remove</code></td><td>仅去掉 Markdown 中 <code>img src</code> 里的 <code>/</code>（<strong>单独执行</strong>）</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sync_folders</span>(<span class="params">src, dest</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    同步 source/images 到 public/images，确保文件和目录保持一致。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(src):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;源目录 <span class="subst">&#123;src&#125;</span> 不存在！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dest):</span><br><span class="line">        os.makedirs(dest)  <span class="comment"># 如果目标文件夹不存在，则创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(src):</span><br><span class="line">        rel_path = os.path.relpath(root, src)</span><br><span class="line">        target_dir = os.path.join(dest, rel_path)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(target_dir):</span><br><span class="line">            os.makedirs(target_dir)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            src_file = os.path.join(root, file)</span><br><span class="line">            dest_file = os.path.join(target_dir, file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dest_file) <span class="keyword">or</span> os.path.getmtime(src_file) &gt; os.path.getmtime(dest_file):</span><br><span class="line">                shutil.copy2(src_file, dest_file)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;同步文件: <span class="subst">&#123;src_file&#125;</span> -&gt; <span class="subst">&#123;dest_file&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;图片同步完成！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_image_paths_in_markdown</span>(<span class="params">posts_folder, mode</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    遍历 source/_posts 目录下所有 .md 文件，修改 img 标签中的 src 路径。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        posts_folder: Markdown 文件所在目录（如 source/_posts）</span></span><br><span class="line"><span class="string">        mode: &quot;remove_slash&quot; -&gt; 移除 img src 里开头的 &quot;/&quot;</span></span><br><span class="line"><span class="string">              &quot;add_slash&quot; -&gt; 给 img src 里开头增加 &quot;/&quot;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(posts_folder):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Markdown 目录 <span class="subst">&#123;posts_folder&#125;</span> 不存在！&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 正则匹配 `&lt;img src=&quot;...&quot;` 语法</span></span><br><span class="line">    pattern_remove_slash = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(&lt;img src=&quot;)/(\.\./images/[^&quot;]+&quot;)&#x27;</span>)</span><br><span class="line">    pattern_add_slash = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(&lt;img src=&quot;)(\.\./images/[^&quot;]+&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    modified_files = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(posts_folder):</span><br><span class="line">        <span class="keyword">if</span> filename.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">            file_path = os.path.join(posts_folder, filename)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                content = f.read()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据模式修改</span></span><br><span class="line">            <span class="keyword">if</span> mode == <span class="string">&quot;remove_slash&quot;</span>:</span><br><span class="line">                new_content = pattern_remove_slash.sub(<span class="string">r&#x27;\1\2&#x27;</span>, content)</span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="string">&quot;add_slash&quot;</span>:</span><br><span class="line">                new_content = pattern_add_slash.sub(<span class="string">r&#x27;\1/\2&#x27;</span>, content)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;未知模式：<span class="subst">&#123;mode&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果内容发生变化，则写入文件</span></span><br><span class="line">            <span class="keyword">if</span> content != new_content:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(new_content)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;已修改文件: <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line">                modified_files += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Markdown 文件路径修改完成，共修改 <span class="subst">&#123;modified_files&#125;</span> 个文件！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 设置文件夹路径</span></span><br><span class="line">    source_images = <span class="string">&quot;source/images&quot;</span></span><br><span class="line">    public_images = <span class="string">&quot;public/images&quot;</span></span><br><span class="line">    markdown_folder = <span class="string">&quot;source/_posts&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析命令行参数</span></span><br><span class="line">    args = <span class="built_in">set</span>(arg.lower() <span class="keyword">for</span> arg <span class="keyword">in</span> sys.argv[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;用法: python sync_and_modify.py [sync] [add] | remove&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;remove&quot;</span> <span class="keyword">in</span> args <span class="keyword">and</span> <span class="built_in">len</span>(args) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：remove 只能单独执行，不能与 sync 或 add 组合！&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;sync&quot;</span> <span class="keyword">in</span> args:</span><br><span class="line">        sync_folders(source_images, public_images)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;add&quot;</span> <span class="keyword">in</span> args:</span><br><span class="line">        modify_image_paths_in_markdown(markdown_folder, mode=<span class="string">&quot;add_slash&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;remove&quot;</span> <span class="keyword">in</span> args:</span><br><span class="line">        modify_image_paths_in_markdown(markdown_folder, mode=<span class="string">&quot;remove_slash&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><br>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用 hexo 写 blog 插入图片时，大多数会使用 typora&amp;#x2F;markdown allin one 等去 preview，此时的(preview) img path 是相对 source&amp;#x2F;_posts&amp;#x2F;**.md 文档的路径；而 gi</summary>
      
    
    
    
    <category term="技术杂谈" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>802.15.4-mac_frm_general_review</title>
    <link href="http://example.com/wiki/802-15-4-mac-frm/"/>
    <id>http://example.com/wiki/802-15-4-mac-frm/</id>
    <published>2025-03-10T11:23:52.000Z</published>
    <updated>2025-03-31T00:20:14.857Z</updated>
    
    <content type="html"><![CDATA[<p>主要介绍了 802.15.4 mac layer pdu 形式与各 bit 含义, 及各 field 内容</p><hr style="border: 2px solid #000; margin: 20px 0;"><h2 id="General-MAC-frame-format"><a href="#General-MAC-frame-format" class="headerlink" title="General MAC frame format"></a>General MAC frame format</h2><center><img src="/../images/802-15-4-mac-frm/1_general_format.png" width="800px"></center><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="frm-control"><a href="#frm-control" class="headerlink" title="frm control"></a>frm control</h3><table><thead><tr><th>Bits</th><th>0–2</th><th>3</th><th>4–5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10–11</th><th>12–13</th><th>14–15</th></tr></thead><tbody><tr><td>Field</td><td>Frame Type</td><td>Security Enabled</td><td>Frame Pending</td><td>AR</td><td>PAN ID Compression</td><td>Reserved</td><td>Sequence Number Suppression</td><td>IE Present</td><td>Destination Addressing Mode</td><td>Frame Version</td></tr></tbody></table><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="mac-frm-type"><a href="#mac-frm-type" class="headerlink" title="mac frm type"></a>mac frm type</h3><table><thead><tr><th>b2</th><th>b1</th><th>b0</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>Beacon</td></tr><tr><td>0</td><td>0</td><td>1</td><td>Data</td></tr><tr><td>0</td><td>1</td><td>0</td><td>Acknowledgment</td></tr><tr><td>0</td><td>1</td><td>1</td><td>MAC command</td></tr><tr><td>1</td><td>0</td><td>0</td><td>Reserved</td></tr><tr><td>1</td><td>0</td><td>1</td><td>Multipurpose</td></tr><tr><td>1</td><td>1</td><td>0</td><td>Fragment or Fraka</td></tr><tr><td>1</td><td>1</td><td>1</td><td>Extended</td></tr></tbody></table><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="Security-Enabled-字段解析"><a href="#Security-Enabled-字段解析" class="headerlink" title="Security Enabled 字段解析"></a>Security Enabled 字段解析</h3><h4 id="字段功能"><a href="#字段功能" class="headerlink" title="字段功能"></a>字段功能</h4><p><code>Security Enabled</code> 字段用于指示 MAC 子层是否对该帧进行了安全保护。</p><table><thead><tr><th>Security Enabled 值</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>启用 MAC 层安全保护，帧头包含<strong>Auxiliary Security Header</strong></td></tr><tr><td>0</td><td>未启用安全保护，帧头不包含<strong>Auxiliary Security Header</strong></td></tr></tbody></table><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="Frame-Pending-字段解析"><a href="#Frame-Pending-字段解析" class="headerlink" title="Frame Pending 字段解析"></a>Frame Pending 字段解析</h3><h4 id="字段功能-1"><a href="#字段功能-1" class="headerlink" title="字段功能"></a>字段功能</h4><p><code>Frame Pending</code> 字段用于指示发送设备是否有更多数据等待发送给接收设备。  </p><table><thead><tr><th>Frame Pending 值</th><th>作用</th></tr></thead><tbody><tr><td>1</td><td>发送设备仍有待发送的数据，接收设备应继续监听</td></tr><tr><td>0</td><td>发送设备无待发送数据，接收设备可进入低功耗模式</td></tr></tbody></table><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><h5 id="信标帧（Beacon-Frame）"><a href="#信标帧（Beacon-Frame）" class="headerlink" title="信标帧（Beacon Frame）"></a>信标帧（Beacon Frame）</h5><ul><li>仅在信标帧（Beacon Frame）或在 <strong>信标使能 PAN</strong>（beacon-enabled PAN）内的 <strong>CAP 时段</strong> 发送的数据帧中使用。  </li><li>在 <strong>非信标使能 PAN</strong>（nonbeacon-enabled PAN）中，可在任意时间使用该字段。</li></ul><h5 id="低能耗（LE）CSL-模式"><a href="#低能耗（LE）CSL-模式" class="headerlink" title="低能耗（LE）CSL 模式"></a>低能耗（LE）CSL 模式</h5><ul><li>若 <code>Frame Pending = 1</code>，表示发送设备仍有数据，并期望接收设备保持射频（RF）开启，直到 <code>Frame Pending</code> 变为 0。</li></ul><h5 id="TSCH-模式"><a href="#TSCH-模式" class="headerlink" title="TSCH 模式"></a>TSCH 模式</h5><ul><li>若 <code>Frame Pending = 1</code>，表示接收设备在 <strong>下一时隙（timeslot）</strong> 仍需保持在线，并在相同信道等待数据（若当前无调度的链路）。</li></ul><h4 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h4><ul><li>除上述情况外，<code>Frame Pending</code> 字段在 <strong>发送时应始终设为 0</strong>，接收时应忽略该字段。</li></ul><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="AR-字段解析"><a href="#AR-字段解析" class="headerlink" title="AR 字段解析"></a>AR 字段解析</h3><h4 id="字段功能-2"><a href="#字段功能-2" class="headerlink" title="字段功能"></a>字段功能</h4><p><code>AR</code>（Acknowledgment Request，确认请求）字段用于指定接收设备在收到数据帧（Data Frame）或 MAC 命令帧（MAC Command Frame）后，是否需要发送确认帧（Ack Frame）。</p><h4 id="字段规则"><a href="#字段规则" class="headerlink" title="字段规则"></a>字段规则</h4><table><thead><tr><th>AR 值</th><th>是否需要 Ack</th><th>适用场景</th></tr></thead><tbody><tr><td>1</td><td>需要</td><td>关键数据，MAC 命令，可靠传输</td></tr><tr><td>0</td><td>不需要</td><td>广播帧，非关键数据，低功耗场景</td></tr></tbody></table><h4 id="AR-字段的影响"><a href="#AR-字段的影响" class="headerlink" title="AR 字段的影响"></a>AR 字段的影响</h4><h5 id="提高传输可靠性"><a href="#提高传输可靠性" class="headerlink" title="提高传输可靠性"></a>提高传输可靠性</h5><p>启用 AR，发送设备可以确保数据成功到达，否则会进行重传（如果支持）。</p><h5 id="降低能耗"><a href="#降低能耗" class="headerlink" title="降低能耗"></a>降低能耗</h5><p>关闭 AR 可以减少额外的 Ack 传输，从而降低设备功耗，适用于低功耗 IoT 设备。</p><h5 id="优化信道占用"><a href="#优化信道占用" class="headerlink" title="优化信道占用"></a>优化信道占用</h5><p>在高流量网络中，避免不必要的 Ack，可以减少信道竞争，提高整体通信效率。</p><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="PAN-ID-Compression-字段解析"><a href="#PAN-ID-Compression-字段解析" class="headerlink" title="PAN ID Compression 字段解析"></a>PAN ID Compression 字段解析</h3><h4 id="字段作用"><a href="#字段作用" class="headerlink" title="字段作用"></a>字段作用</h4><p><code>PAN ID Compression</code> 字段用于指示 <strong>PAN ID（个人区域网络标识）</strong> 是否包含在 MAC 帧中，以减少数据开销。</p><h4 id="解析规则"><a href="#解析规则" class="headerlink" title="解析规则"></a>解析规则</h4><ul><li><p>当 <strong>帧版本（Frame Version）字段值</strong> 为 <code>0b00</code> 或 <code>0b01</code> 时：</p><ul><li><strong>同时包含目标地址和源地址时</strong>：<ul><li>若 <strong>目标 PAN ID 与源 PAN ID 相同</strong>，则 <code>PAN ID Compression</code> 设为 <code>1</code>，省略 <code>Source PAN ID</code> 字段。</li><li>若 <strong>目标 PAN ID 与源 PAN ID 不同</strong>，则 <code>PAN ID Compression</code> 设为 <code>0</code>，同时包含 <code>Destination PAN ID</code> 和 <code>Source PAN ID</code> 字段。</li></ul></li><li><strong>仅包含目标地址或源地址时</strong>：<ul><li><code>PAN ID Compression</code> 设为 <code>0</code>，并且该地址的 <code>PAN ID</code> 字段必须包含在 MAC 帧中。</li></ul></li></ul></li><li><p>当 <strong>帧版本字段值</strong> 为 <code>0b10</code> 时：</p><ul><li><code>PAN ID Compression</code> 字段的具体设置取决于 <strong>信标帧（Beacon Frame）、数据帧（Data Frame）、MAC 命令帧（MAC Command Frame）和确认帧（Ack Frame）</strong> 的地址格式，并遵循 <strong>表 7-2</strong> 规定的组合方式。</li><li>任何不符合 <strong>表 7-2</strong> 规定的组合方式不应生成。</li></ul></li></ul><table><thead><tr><th>Destination Address</th><th>Source Address</th><th>Destination PAN ID</th><th>Source PAN ID</th><th>PAN ID Compression</th></tr></thead><tbody><tr><td>Not Present</td><td>Not Present</td><td>Not Present</td><td>Not Present</td><td>0</td></tr><tr><td>Not Present</td><td>Not Present</td><td>Present</td><td>Not Present</td><td>1</td></tr><tr><td>Present</td><td>Not Present</td><td>Present</td><td>Not Present</td><td>0</td></tr><tr><td>Present</td><td>Not Present</td><td>Not Present</td><td>Not Present</td><td>1</td></tr><tr><td>Not Present</td><td>Present</td><td>Not Present</td><td>Present</td><td>0</td></tr><tr><td>Not Present</td><td>Present</td><td>Not Present</td><td>Not Present</td><td>1</td></tr><tr><td>Extended</td><td>Extended</td><td>Present</td><td>Not Present</td><td>0</td></tr><tr><td>Extended</td><td>Extended</td><td>Not Present</td><td>Not Present</td><td>1</td></tr><tr><td>Shorta</td><td>Shorta</td><td>Present</td><td>Present</td><td>0</td></tr><tr><td>Shorta</td><td>Extended</td><td>Present</td><td>Present</td><td>0</td></tr><tr><td>Extended</td><td>Shorta</td><td>Present</td><td>Present</td><td>0</td></tr><tr><td>Shorta</td><td>Extended</td><td>Present</td><td>Not Present</td><td>1</td></tr><tr><td>Extended</td><td>Shorta</td><td>Present</td><td>Not Present</td><td>1</td></tr><tr><td>Shorta</td><td>Shorta</td><td>Present</td><td>Not Present</td><td>1</td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>PAN ID Compression 值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>目标 PAN ID 与源 PAN ID 相同，省略 <code>Source PAN ID</code></td></tr><tr><td>0</td><td>目标 PAN ID 与源 PAN ID 不同，需包含 <code>Destination PAN ID</code> 和 <code>Source PAN ID</code></td></tr></tbody></table><p>该字段的使用可以有效减少 MAC 帧长度，优化网络通信效率。📡</p><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="Sequence-Number-Suppression-字段"><a href="#Sequence-Number-Suppression-字段" class="headerlink" title="Sequence Number Suppression 字段"></a>Sequence Number Suppression 字段</h3><h4 id="字段作用-1"><a href="#字段作用-1" class="headerlink" title="字段作用"></a>字段作用</h4><p><code>Sequence Number Suppression</code> 字段用于指示是否压制帧中的 <strong>Sequence Number（序列号）</strong> 字段。</p><table><thead><tr><th>Sequence Number Suppression 值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>序列号字段被压制，省略序列号</td></tr><tr><td>0</td><td>序列号字段存在</td></tr></tbody></table><ul><li><strong>特殊情况：</strong><ul><li>如果 <strong>Frame Version（帧版本）字段</strong> 的值为 <code>0b00</code> 或 <code>0b01</code>，则 <code>Sequence Number Suppression</code> 字段必须为 <code>0</code>，即 <strong>序列号字段必须存在</strong>。</li></ul></li></ul><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="IE-Present-字段"><a href="#IE-Present-字段" class="headerlink" title="IE Present 字段"></a>IE Present 字段</h3><h4 id="字段作用-2"><a href="#字段作用-2" class="headerlink" title="字段作用"></a>字段作用</h4><p><code>IE Present</code> 字段用于指示帧中是否包含 <strong>Information Elements (IEs)</strong>。</p><table><thead><tr><th>IE Present 值</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>帧中包含 IEs</td></tr><tr><td>0</td><td>帧中不包含 IEs</td></tr></tbody></table><ul><li><strong>特殊情况：</strong><ul><li>如果 <strong>Frame Version（帧版本）字段</strong> 的值为 <code>0b00</code> 或 <code>0b01</code>，则 <code>IE Present</code> 字段必须为 <code>0</code>，即帧中不包含 IEs。</li></ul></li></ul><p>此字段的设置对于确定帧的内容和处理方式非常重要。📦</p><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="Destination-Addressing-Mode-字段"><a href="#Destination-Addressing-Mode-字段" class="headerlink" title="Destination Addressing Mode 字段"></a>Destination Addressing Mode 字段</h3><h4 id="字段作用-3"><a href="#字段作用-3" class="headerlink" title="字段作用"></a>字段作用</h4><p><code>Destination Addressing Mode</code> 字段用于指定帧的目标地址模式。此字段的值可以根据不同的帧类型和版本来决定帧的地址格式。</p><h4 id="解析规则-1"><a href="#解析规则-1" class="headerlink" title="解析规则"></a>解析规则</h4><ul><li><p><strong>Destination Addressing Mode</strong> 字段应设置为 <strong>Table 7-3</strong> 中列出的值之一。</p></li><li><p>如果 <strong>Destination Addressing Mode</strong> 字段的值为 <code>0</code> 且 <strong>Frame Type（帧类型）字段</strong> 指定为 <strong>Data frame</strong> 或 <strong>MAC command</strong> 且 <strong>Frame Version（帧版本）字段</strong> 为 <code>0b00</code> 或 <code>0b01</code>：</p><ul><li><strong>Source Addressing Mode（源地址模式）字段</strong> 必须为非零值，表示帧是发送给 <strong>PAN coordinator</strong>，并且帧中的 <strong>Source PAN ID</strong> 字段指定了 PAN ID。</li></ul></li><li><p>对于帧版本为 <code>0b10</code> 的情况：</p><ul><li><strong>Destination Address</strong> 或 <strong>Destination PAN ID</strong> 或两者可能会被省略。</li></ul></li></ul><table><thead><tr><th>b1</th><th>b0</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>PAN ID and address fields are not present.</td></tr><tr><td>0</td><td>1</td><td>Reserved</td></tr><tr><td>1</td><td>0</td><td>Address field contains a short address (16 bit).</td></tr><tr><td>1</td><td>1</td><td>Address field contains an extended address (64 bit).</td></tr></tbody></table><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>Destination Addressing Mode 值</th><th>含义</th></tr></thead><tbody><tr><td><code>0</code></td><td>指定源地址信息，并且帧是发送给 PAN 协调器。</td></tr><tr><td>其他值</td><td>由 Table 7-3 定义，决定目标地址模式。</td></tr></tbody></table><p>此字段定义了如何在数据帧中表示目标地址，影响帧的传输和处理。📡</p><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="Frame-Version-字段"><a href="#Frame-Version-字段" class="headerlink" title="Frame Version 字段"></a>Frame Version 字段</h3><h4 id="字段作用-4"><a href="#字段作用-4" class="headerlink" title="字段作用"></a>字段作用</h4><p><code>Frame Version</code> 字段是一个无符号整数，用于指定与帧对应的版本号。所有帧类型都应按照各自子条款中描述的方式设置 <strong>Frame Version</strong> 字段。</p><h4 id="版本总结"><a href="#版本总结" class="headerlink" title="版本总结"></a>版本总结</h4><ul><li><strong>Frame Version</strong> 字段决定了帧的版本号。</li><li>每种帧类型有不同的版本号要求，这些要求在 <strong>Table 7-4</strong> 中进行了总结。</li></ul><h4 id="版本适用性"><a href="#版本适用性" class="headerlink" title="版本适用性"></a>版本适用性</h4><p>每个帧类型的适用版本总结如下：</p><table><thead><tr><th>Frame Version</th><th>适用的帧类型</th></tr></thead><tbody><tr><td><code>0b00</code></td><td>适用于特定帧类型，具体请参考 Table 7-4</td></tr><tr><td><code>0b01</code></td><td>适用于特定帧类型，具体请参考 Table 7-4</td></tr><tr><td><code>0b10</code></td><td>适用于特定帧类型，具体请参考 Table 7-4</td></tr></tbody></table><table><thead><tr><th>Frame Type</th><th>Frame Version 0b00</th><th>Frame Version 0b01</th><th>Frame Version 0b10</th><th>Frame Version 0b11</th></tr></thead><tbody><tr><td>Beacon</td><td>IEEE Std 802.15.4-2003</td><td>IEEE Std 802.15.4-2006</td><td>IEEE Std 802.15.4</td><td>Reserved</td></tr><tr><td>Data</td><td>IEEE Std 802.15.4-2003</td><td>IEEE Std 802.15.4-2006</td><td>IEEE Std 802.15.4</td><td>Reserved</td></tr><tr><td>Acknowledgment</td><td>IEEE Std 802.15.4-2003</td><td>IEEE Std 802.15.4-2006</td><td>IEEE Std 802.15.4</td><td>Reserved</td></tr><tr><td>MAC Command</td><td>IEEE Std 802.15.4-2003</td><td>IEEE Std 802.15.4-2006</td><td>IEEE Std 802.15.4</td><td>Reserved</td></tr><tr><td>Reserved</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td>Multipurpose</td><td>IEEE Std 802.15.4</td><td>Reserved</td><td>Reserved</td><td>Reserved</td></tr><tr><td>Fragment</td><td>Frame Version field not present in frame</td><td>Frame Version field not present in frame</td><td>Frame Version field not present in frame</td><td>Frame Version field not present in frame</td></tr><tr><td>Extended</td><td>Frame Version field not present in frame</td><td>Frame Version field not present in frame</td><td>Frame Version field not present in frame</td><td>Frame Version field not present in frame</td></tr></tbody></table><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="Source-Addressing-Mode-field"><a href="#Source-Addressing-Mode-field" class="headerlink" title="Source Addressing Mode field"></a>Source Addressing Mode field</h3><ul><li><strong>Source Addressing Mode</strong> 字段的值应设置为 <strong>Table 7-3</strong> 中列出的值之一。</li><li>当该字段为 <code>0</code> 且 <strong>Frame Type</strong> 字段指定为 <strong>Data frame</strong> 或 <strong>MAC command</strong>，并且 <strong>Frame Version</strong> 字段为 <code>0b00</code> 或 <code>0b01</code>，则 <strong>Destination Addressing Mode</strong> 字段必须为非零。</li><li>这种情况下，意味着该帧源自 <strong>PAN coordinator</strong>，其 <strong>PAN ID</strong> 由 <strong>Destination PAN ID</strong> 字段指定。</li></ul><hr><h3 id="Sequence-Number-field"><a href="#Sequence-Number-field" class="headerlink" title="Sequence Number field"></a>Sequence Number field</h3><ul><li><strong>Sequence Number</strong> 字段用于指定该帧的序列标识符。</li><li>对于 <strong>Beacon frame</strong>，该字段指定 <strong>BSN (Beacon Sequence Number)</strong>。</li><li>对于其他帧，该字段指定 <strong>DSN (Data Sequence Number)</strong>。</li></ul><hr><h3 id="Destination-PAN-ID-field"><a href="#Destination-PAN-ID-field" class="headerlink" title="Destination PAN ID field"></a>Destination PAN ID field</h3><ul><li><strong>Destination PAN ID</strong> 字段（如果存在）是一个无符号整数，指定目标设备所在的 <strong>PAN ID</strong>。</li><li>如果该字段的值为 <strong>广播 PAN ID</strong>（定义见 6.1），则所有当前监听该信道的设备都将其视为有效 <strong>PAN ID</strong>。</li></ul><hr><h3 id="Destination-Address-field"><a href="#Destination-Address-field" class="headerlink" title="Destination Address field"></a>Destination Address field</h3><ul><li><strong>Destination Address</strong> 字段（如果存在）用于指定帧的接收者地址。</li><li>其长度由 <strong>Frame Control</strong> 字段的 <strong>Destination Addressing Mode</strong>（见 7.2.1.8）决定。</li><li>如果该字段的值为 <strong>广播短地址</strong>（定义见 6.1），则所有当前监听该信道的设备都将其视为有效地址。</li><li>该字段仅在 <strong>Destination Addressing Mode</strong> 字段非零时才包含在 MAC 帧中。</li></ul><hr><h3 id="Source-PAN-ID-field"><a href="#Source-PAN-ID-field" class="headerlink" title="Source PAN ID field"></a>Source PAN ID field</h3><ul><li><strong>Source PAN ID</strong> 字段（如果存在）用于指定该帧的发送者所属于的 <strong>PAN ID</strong>。</li><li>设备的 <strong>PAN ID</strong> 初始由其加入 <strong>PAN</strong> 时决定，但可能会因 <strong>PAN ID 冲突解决</strong>（见 6.3.2）而发生变化。</li></ul><hr><h3 id="Source-Address-field"><a href="#Source-Address-field" class="headerlink" title="Source Address field"></a>Source Address field</h3><ul><li><strong>Source Address</strong> 字段（如果存在）用于指定该帧的发送者地址。</li><li>该字段仅在 <strong>Source Addressing Mode</strong> 字段非零时才包含在 <strong>MAC 帧</strong> 中。</li></ul><hr><h3 id="Auxiliary-Security-Header-field"><a href="#Auxiliary-Security-Header-field" class="headerlink" title="Auxiliary Security Header field"></a>Auxiliary Security Header field</h3><ul><li><strong>Auxiliary Security Header</strong> 字段包含用于 <strong>安全处理</strong> 所需的信息。</li><li>该字段仅在 <strong>Security Enabled</strong> 字段设为 <code>1</code> 时才会存在。</li><li><strong>Auxiliary Security Header</strong> 字段的格式详见 <strong>9.4</strong>。</li></ul><hr><h3 id="IE-Field"><a href="#IE-Field" class="headerlink" title="IE Field"></a>IE Field</h3><ul><li><strong>IE（Information Element）字段</strong> 为可变长度，包含一个或多个 <strong>IE</strong>。</li><li>由 <strong>Header IE</strong> 和 <strong>Payload IE</strong> 子字段组成。</li><li>该字段仅在 <strong>Frame Control</strong> 字段中的 <strong>IE Present</strong> 设为 <code>1</code> 时才会存在。</li><li>每个 <strong>IE</strong> 由 <strong>描述符（descriptor）</strong> 和 <strong>可选负载（optional payload）</strong> 组成，具体描述见 <strong>7.4</strong>。</li></ul><h4 id="Header-IE"><a href="#Header-IE" class="headerlink" title="Header IE"></a>Header IE</h4><ul><li><strong>Header IE</strong>（如果存在）位于 <strong>Auxiliary Security Header</strong> 之后，属于 <strong>MHR（MAC Header）</strong>。</li></ul><h4 id="Payload-IE"><a href="#Payload-IE" class="headerlink" title="Payload IE"></a>Payload IE</h4><ul><li><strong>Payload IE</strong>（如果存在）位于 <strong>MHR</strong> 之后，属于 <strong>MAC payload</strong>，即 <strong>Payload IE</strong> 可能被加密。</li></ul><table><thead><tr><th>Octets</th><th>Variable … Variable</th><th>0&#x2F;2</th><th>Variable … Variable</th><th>0&#x2F;2</th></tr></thead><tbody><tr><td>Field</td><td>Header IE #1 … Header IE #n</td><td>Header Termination IE</td><td>Payload IE #1 … Payload IE #m</td><td>Payload Termination IE</td></tr></tbody></table><hr><h3 id="7-2-9-Frame-Payload-Field"><a href="#7-2-9-Frame-Payload-Field" class="headerlink" title="7.2.9 Frame Payload Field"></a>7.2.9 Frame Payload Field</h3><ul><li><strong>Frame Payload 字段</strong> 包含特定于各帧类型的信息。</li><li>如果 <strong>Security Enabled</strong> 字段设为 <code>1</code>，则 <strong>Frame Payload</strong> 可能受到 <strong>加密保护</strong>，详见 <strong>Clause 9</strong>。</li></ul><hr><h3 id="7-2-10-FCS-Field"><a href="#7-2-10-FCS-Field" class="headerlink" title="7.2.10 FCS Field"></a>7.2.10 FCS Field</h3><ul><li><strong>FCS（Frame Check Sequence）字段</strong> 包含一个 <strong>16-bit ITU-T CRC</strong> 或 <strong>32-bit CRC</strong>（符合 <strong>ANSI X3.66-1979.13</strong>）。</li><li><strong>FCS 计算范围</strong> 包括 <strong>MHR</strong> 和 <strong>MAC Payload</strong>，统称为 <strong>计算字段（Calculation Field）</strong>。</li><li>兼容 <strong>SUN PHYs</strong> 或 <strong>TVWS PHYs</strong> 的设备必须实现 <strong>4-octet FCS</strong>。</li></ul><hr style="border: 2px solid #000; margin: 20px 0;"><h3 id="7-4-1-IE-List-Termination"><a href="#7-4-1-IE-List-Termination" class="headerlink" title="7.4.1 IE List Termination"></a>7.4.1 IE List Termination</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li>在确定 <strong>Header IEs</strong> 或 <strong>Payload IEs</strong> 是否需要终止时，<strong>不考虑</strong> 认证或加密过程。</li><li><strong>下面的table</strong> 规定了 terminate IE ：<ul><li><strong>HT1</strong>（Header Termination 1 IE），定义见 <strong>7.4.2.17</strong>。</li><li><strong>HT2</strong>（Header Termination 2 IE），定义见 <strong>7.4.2.18</strong>。</li></ul></li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote><p><strong>Header Termination IE 必须出现在 Payload IEs 之前</strong>，因为 <strong>Header IEs</strong> 和 <strong>Payload IEs</strong> <strong>共享地址空间</strong>，无法直接区分二者的边界。因此，需要使用 <strong>Header Termination IE</strong> 来标识 <strong>Header IEs 的结束</strong> 和 <strong>Payload IEs 的开始</strong>。</p></blockquote><table><thead><tr><th>Header IEs Present</th><th>Payload IEs Present</th><th>Data Payload Present</th><th>Header Termination IE Included</th><th>Payload Termination IE Included</th><th>Notes</th></tr></thead><tbody><tr><td>No</td><td>No</td><td>No</td><td>None</td><td>None</td><td>No IE lists present, hence no termination. Included here for completeness.</td></tr><tr><td>Yes</td><td>No</td><td>No</td><td>None</td><td>None</td><td>No termination is required because the end of the frame can be determined from the frame length and FCS length.</td></tr><tr><td>No</td><td>Yes</td><td>No</td><td>HT1 required</td><td>Optional</td><td>Header Termination IE 1 is required to signal end of the MHR and beginning of the Payload IE list.</td></tr><tr><td>Yes</td><td>Yes</td><td>No</td><td>HT1 required</td><td>Optional</td><td>Header Termination IE 1 is required while the Payload IE Termination is not required, but is allowed.</td></tr><tr><td>No</td><td>No</td><td>Yes</td><td>None</td><td>None</td><td>No IE lists present, hence no termination. Included here for completeness.</td></tr><tr><td>Yes</td><td>No</td><td>Yes</td><td>HT2 required</td><td>None</td><td>Header Termination IE 2 is used to signal end of the MHR and beginning of the MAC Payload.</td></tr><tr><td>No</td><td>Yes</td><td>Yes</td><td>HT1 required</td><td>Required</td><td>—</td></tr><tr><td>Yes</td><td>Yes</td><td>Yes</td><td>HT1 required</td><td>Required</td><td>—</td></tr></tbody></table><hr><h5 id="header-ie"><a href="#header-ie" class="headerlink" title="header ie"></a>header ie</h5><p>HT1 &#x2F; HT2 ie 也使用了下表的格式，只不过 content len &#x3D; 0, ElementID &#x3D; 0x7E&#x2F;7F;</p><p>Element ID 的使用，直接就代表了具体的 header ie,  而 payload IE 中的 Group ID 则代表了更多无限的可能 ～ Group 下还有 Nest IE ～ sub-ID</p><table><thead><tr><th>Bits</th><th>0–6</th><th>7–14</th><th>15</th><th>0–127</th></tr></thead><tbody><tr><td>Field</td><td>Length</td><td>Element ID</td><td>Type &#x3D; 0</td><td>Content</td></tr></tbody></table><h5 id="payload-ie"><a href="#payload-ie" class="headerlink" title="payload ie"></a>payload ie</h5><table><thead><tr><th>Bits</th><th>0–10</th><th>11–14</th><th>15</th><th>0–2047</th></tr></thead><tbody><tr><td>Field</td><td>Length</td><td>Group ID</td><td>Type &#x3D; 1</td><td>Content</td></tr></tbody></table><h6 id="nested-short-long-ie-payload-ie-group-Id-mlme-0x1"><a href="#nested-short-long-ie-payload-ie-group-Id-mlme-0x1" class="headerlink" title="nested short&#x2F;long ie ~ payload ie ~ group Id &#x3D; mlme(0x1)"></a>nested short&#x2F;long ie ~ payload ie ~ group Id &#x3D; mlme(0x1)</h6><p>nested ie 下又分出了很多 sub id ie</p><table><thead><tr><th>Bits</th><th>0–7</th><th>8–14</th><th>15</th><th>0–255</th></tr></thead><tbody><tr><td>Field</td><td>Length</td><td>Sub-ID</td><td>Type &#x3D; 0</td><td>Content</td></tr></tbody></table><table><thead><tr><th>Bits</th><th>0–10</th><th>11–14</th><th>15</th><th>0–2047</th></tr></thead><tbody><tr><td>Field</td><td>Length</td><td>Sub-ID</td><td>Type &#x3D; 0</td><td>Content</td></tr></tbody></table><hr style="border: 2px solid #000; margin: 20px 0;"><hr style="border: 2px solid #000; margin: 20px 0;"><p>主要介绍了 802.15.4 具体的 frm type 对应的 mac frm formats</p><p><strong>beacon frm</strong></p><center><img src="/../images/802-15-4-mac-frm/4_beacon_frm.png" width="800px"></center><p><strong>data frm</strong></p><center><img src="/../images/802-15-4-mac-frm/5_data_frm.png" width="800px"></center><p><strong>ack frm</strong></p><center><img src="/../images/802-15-4-mac-frm/6_imm_ack.png" width="400px"></center><center><img src="/../images/802-15-4-mac-frm/7_enh_ack.png" width="800px"></center><p><strong>mac cmd frm</strong></p><center><img src="/../images/802-15-4-mac-frm/8_mac_cmd.png" width="800px"></center><p><strong>multipurpose frm</strong></p><center><img src="/../images/802-15-4-mac-frm/9_multi.png" width="800px"></center><p><strong>ext frm</strong></p><center><img src="/../images/802-15-4-mac-frm/10_ext.png" width="600px"></center>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要介绍了 802.15.4 mac layer pdu 形式与各 bit 含义, 及各 field 内容&lt;/p&gt;
&lt;hr style=&quot;border: 2px solid #000; margin: 20px 0;&quot;&gt;

&lt;h2 id=&quot;General-MAC-frame</summary>
      
    
    
    
    <category term="802.15.4" scheme="http://example.com/categories/802-15-4/"/>
    
    
    <category term="802.15.4" scheme="http://example.com/tags/802-15-4/"/>
    
  </entry>
  
  <entry>
    <title>802.15.4-mac_sec_related</title>
    <link href="http://example.com/wiki/802-15-4-sec-related/"/>
    <id>http://example.com/wiki/802-15-4-sec-related/</id>
    <published>2025-03-08T02:54:19.000Z</published>
    <updated>2025-03-31T00:06:49.024Z</updated>
    
    <content type="html"><![CDATA[<p>以 drawio 流程图的形式介绍了 802.15.4(2015) mac layer 的加解密，主要有：incoming frm dec, outcoming frm enc, secure related PIBs。</p><p><em>注：802.15.4 2015&#x2F;2006&#x2F;2003 版本加解密flow上存在差异,点击流程图可以全屏展开</em></p><hr style="border: 2px solid #000; margin: 20px 0;"><h2 id="outgoing-frm-enc"><a href="#outgoing-frm-enc" class="headerlink" title="outgoing frm - enc"></a>outgoing frm - enc</h2><iframe src="https://muyin568.github.io/drawio_htmls/incoming_dec-enc-2015.drawio.html" width="125%" height="300"></iframe><br/><hr><h2 id="incoming-frm-sec-on-dec"><a href="#incoming-frm-sec-on-dec" class="headerlink" title="incoming frm - sec on - dec"></a>incoming frm - sec on - dec</h2><iframe src="https://muyin568.github.io/drawio_htmls/incoming_dec-dec-secOn-2015.drawio.html" width="125%" height="300"></iframe><br/><hr><h2 id="incoming-frm-sec-on-dec-1"><a href="#incoming-frm-sec-on-dec-1" class="headerlink" title="incoming frm - sec on - dec"></a>incoming frm - sec on - dec</h2><iframe src="https://muyin568.github.io/drawio_htmls/incoming_dec-dec-secOff-2015.drawio.html" width="125%" height="300"></iframe><br/><hr><h2 id="sec-pib-related"><a href="#sec-pib-related" class="headerlink" title="sec pib related"></a>sec pib related</h2><iframe src="https://muyin568.github.io/drawio_htmls/incoming_dec-sec-pib-2015.drawio.html" width="125%" height="400"></iframe><br/>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以 drawio 流程图的形式介绍了 802.15.4(2015) mac layer 的加解密，主要有：incoming frm dec, outcoming frm enc, secure related PIBs。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：802.15.4 2015</summary>
      
    
    
    
    <category term="802.15.4" scheme="http://example.com/categories/802-15-4/"/>
    
    
    <category term="802.15.4" scheme="http://example.com/tags/802-15-4/"/>
    
  </entry>
  
</feed>
