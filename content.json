{"pages":[{"title":"About","date":"2025-03-11T14:11:10.173Z","path":"about/index.html","text":""},{"title":"categories","date":"2025-03-12T00:21:03.000Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2025-03-12T23:44:41.796Z","path":"tags/index.html","text":""}],"posts":[{"title":"freertos-overview && task","date":"2025-04-07T00:05:54.000Z","path":"wiki/freertos/","text":"学习 freertos kernel layer 内容，运行原理 FreeRTOS 架构总览 层级 描述 应用层 (Application Layer) 用户自定义任务、回调函数，调用 FreeRTOS API 内核层 (Kernel Layer) 任务管理、调度器、内存管理、任务间通信、软件定时器等核心功能 硬件抽象层 (Porting Layer) 硬件相关实现：上下文切换、Tick 中断处理 硬件层 (Hardware Layer) CPU、定时器、中断控制器、外设等硬件资源 kernel layer 模块 主要功能 对应file 任务管理 (Task Management) 任务创建、删除、挂起、恢复，任务优先级，TCB（任务控制块） tasks.c, tasks.h 调度器 (Scheduler) 抢占式调度、时间片轮转调度 tasks.c, tasks.h 时间管理 (Time Management) Tick 定时器，任务延时 vTaskDelay()、vTaskDelayUntil() timers.c, timers.h, tasks.c 任务间通信 (Inter-task Communication) 队列（Queue）、信号量（Semaphore）、互斥锁（Mutex）、事件组（Event Group） queue.c, queue.h, semphr.c, semphr.h, event_groups.c, event_groups.h 内存管理 (Memory Management) Heap_1 ~ Heap_5，动态&#x2F;静态内存分配 heap_1.c, heap_2.c, heap_3.c, heap_4.c, heap_5.c 软件定时器 (Software Timer) 定时器服务任务，定时器回调处理 timers.c, timers.h 命名规则 数据类型&#x2F;元素 命名规则说明 示例 char 类型 以 c 为字首 cVarName short 类型 以 s 为字首 sVarName long 类型 以 l 为字首 lVarName float 类型 以 f 为字首 fVarName double 类型 以 d 为字首 dVarName Enum 类型 以 e 为字首 eVarName portBASE_TYPE 或 struct 以 x 为字首 xVarName pointer 变量 对应类型前加 p 前缀 psVarName（short 类型的 pointer） unsigned 类型 对应类型前加 u 前缀 usVarName（unsigned short 类型） 函数 以回传值类型和所在文件名为开头（prefix） vTaskPriority()（task.c 中的 void 类型函数） 回传值为 portBASE_TYPE 的函数 以回传值类型和文件名为开头 xQueueReceive()（queue.c 中的 portBASE_TYPE 类型函数） 私有函数（仅限文件内使用） 以 prv 为开头（private function） prvPrivateFunction() 宏定义 宏名称为大写字母，定义文件名的小写字母作为前缀 portMAX_DELAY（portable.h） 配置宏定义 宏定义名称前加文件名的小写字母作为前缀 configUSE_PREEMPTION（FreeRTOSConfig.h） task举例典型的 create task flow 创建 task 1&#x2F;2 , 各有一个 msg queue ， 使用 switch 方式处理 task 从 msg queue 里收到的不同 msg 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &quot;FreeRTOS.h&quot;#include &quot;task.h&quot;#include &quot;queue.h&quot;#include &quot;stdio.h&quot;// 定义事件类型（消息类型）typedef enum &#123; MSG_TASK1 = 1, MSG_TASK2, MSG_STOP&#125; MessageType;// 消息结构体，包含消息类型和其他必要的数据typedef struct &#123; MessageType messageType; void *data; // 可以存储额外的数据&#125; EventMessage;// 任务1的事件队列句柄QueueHandle_t xEventQueue1;// 任务2的事件队列句柄QueueHandle_t xEventQueue2;// 任务1的函数void vTask1(void *pvParameters) &#123; EventMessage receivedMessage; for (;;) &#123; // 从任务1的队列接收消息 if (xQueueReceive(xEventQueue1, &amp;receivedMessage, portMAX_DELAY) == pdPASS) &#123; if (receivedMessage.messageType == MSG_TASK1) &#123; printf(&quot;任务1：执行特定操作\\n&quot;); &#125; else if (receivedMessage.messageType == MSG_STOP) &#123; printf(&quot;任务1：停止任务\\n&quot;); vTaskDelete(NULL); // 删除当前任务 &#125; &#125; &#125;&#125;// 任务2的函数void vTask2(void *pvParameters) &#123; EventMessage receivedMessage; for (;;) &#123; // 从任务2的队列接收消息 if (xQueueReceive(xEventQueue2, &amp;receivedMessage, portMAX_DELAY) == pdPASS) &#123; if (receivedMessage.messageType == MSG_TASK2) &#123; printf(&quot;任务2：执行特定操作\\n&quot;); &#125; else if (receivedMessage.messageType == MSG_STOP) &#123; printf(&quot;任务2：停止任务\\n&quot;); vTaskDelete(NULL); // 删除当前任务 &#125; &#125; &#125;&#125;// 初始化任务和队列的函数void initTasks(void) &#123; // 创建任务1的事件队列 xEventQueue1 = xQueueCreate(10, sizeof(EventMessage)); if (xEventQueue1 == NULL) &#123; printf(&quot;任务1的事件队列创建失败！\\n&quot;); return; &#125; // 创建任务2的事件队列 xEventQueue2 = xQueueCreate(10, sizeof(EventMessage)); if (xEventQueue2 == NULL) &#123; printf(&quot;任务2的事件队列创建失败！\\n&quot;); return; &#125; // 创建任务1 if (xTaskCreate(vTask1, &quot;Task1&quot;, 128, NULL, tskIDLE_PRIORITY + 1, NULL) != pdPASS) &#123; printf(&quot;任务1创建失败！\\n&quot;); &#125; // 创建任务2 if (xTaskCreate(vTask2, &quot;Task2&quot;, 128, NULL, tskIDLE_PRIORITY + 2, NULL) != pdPASS) &#123; printf(&quot;任务2创建失败！\\n&quot;); &#125;&#125;int main(void) &#123; // 初始化任务和队列 initTasks(); // 启动调度器 vTaskStartScheduler(); // 如果调度器启动失败，通常会回到这个地方，发生在内存不足时 printf(&quot;调度器启动失败！\\n&quot;); // 永远不应到达这里 for (;;) &#123;&#125; return 0;&#125; task 状态及切换 当前状态 事件&#x2F;操作 下一个状态 Running 时间片用尽 &#x2F; 更高优先级 task awake Ready Running 发生阻塞事件 Blocked Running 显式挂起 Suspended Ready 被调度器选择 Running Ready 抢占低优先级任务 Running Blocked 阻塞事件发生 Ready Blocked 超时 Ready Suspended 被显式恢复 Ready 状态 定义 特点 状态切换 Running 当任务正在实际执行时，任务处于 Running 状态。此时任务正在占用处理器资源。 - 单核处理器：在单核处理器上，任何时刻只有一个任务能够处于 Running 状态。- 多核处理器：多个任务可以在不同核心上处于 Running 状态，但每个核心只能执行一个任务。 - 当任务的时间片用尽或更高优先级的任务被唤醒时，当前任务将会被切换到 Ready 状态。- 如果任务发生阻塞或挂起，任务将退出 Running 状态并转为相应的状态。 Ready 当任务随时可以执行（即不在 Blocked 或 Suspended 状态中）。 - 任务处于 Ready 状态时，它并不会立即执行，而是等待调度器选择它。- 只有优先级最高的任务才会被调度器选择进入 Running 状态。- 或多个相同优先级任务的 RR 切换 - 当有更高优先级的任务进入 Ready 状态，Running 任务会被中断并切换到 Ready 状态。- 如果任务的优先级足够高并且没有其他任务正在执行，任务会被调度进入 Running 状态，抢占其他任务。 Blocked 任务在等待某个事件发生时会进入 Blocked 状态。这些事件通常是临时的（如延迟），或者是外部事件（如等待队列、信号量、事件组等）。 - 任务会在发生阻塞条件（如调用 vTaskDelay()、等待队列、信号量等）时进入 Blocked 状态，直到事件发生，任务才会被唤醒。- 阻塞状态通常会设置一个超时时间，任务在超时后也会被唤醒。- 任务在 Blocked 状态下不占用 CPU 时间。 - 一旦事件发生（如超时、信号量释放、队列接收到数据等），任务会从 Blocked 状态切换到 Ready 状态，等待调度器安排执行。 Suspended 任务可以被显式地挂起进入 Suspended 状态。挂起的任务不会自动恢复执行，必须由程序显式地恢复。 - 任务进入 Suspended 状态后不会占用 CPU 时间，调度器也不会选择该任务执行。- 任务通过调用 vTaskSuspend() 进入该状态，恢复通过 xTaskResume() 实现。- 与 Blocked 状态不同，Suspended 状态没有超时机制。 - 任务通过 vTaskSuspend() 进入 Suspended 状态，直到显式通过 xTaskResume() 恢复，任务才会转到 Ready 状态，等待调度器调度执行。 task creation123456789101112131415161718192021 // 3 related api, 2 create, 1 deleteBaseType_t xTaskCreate( TaskFunction_t pvTaskCode, // 任务函数 const char * const pcName, // 任务名称 uint16_t usStackDepth, // 任务栈大小（单位：字） void *pvParameters, // 传递给任务的参数 UBaseType_t uxPriority, // 任务优先级 TaskHandle_t *pxCreatedTask // 返回任务句柄);TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode, // 任务函数 const char * const pcName, // 任务名称 uint16_t usStackDepth, // 任务栈大小（单位：字） void *pvParameters, // 传递给任务的参数 UBaseType_t uxPriority, // 任务优先级 StackType_t *pxStackBuffer, // 用户提供的栈空间 StaticTask_t *pxTaskBuffer // 用户提供的任务控制块（TCB）);void vTaskDelete( TaskHandle_t xTask ); xTaskCreate xTaskCreateStatic 最主要的区别是 task memory 的来源，tcb + stack 来源于用户分配 &#x2F; 系统分配 特性 xTaskCreate() xTaskCreateStatic() 内存分配方式 动态分配内存，通过 FreeRTOS 内部的堆管理器进行分配。 静态分配内存，使用用户提供的内存块，不依赖动态内存管理。 任务控制块（TCB） 动态分配一个任务控制块（TCB）和任务栈空间。 用户提供自己的任务控制块（TCB）和栈空间。 使用内存 依赖于 pvPortMalloc()（默认的堆分配器）。 直接使用静态内存，避免了堆内存分配和回收的开销。 任务栈 由 xTaskCreate() 内部创建并分配栈空间。 用户提供栈空间，通过 xTaskCreateStatic() 指定栈空间。 调试和优化 动态内存分配可能会引入堆碎片和不确定的内存问题。 静态内存分配更可靠，适用于嵌入式系统，避免了堆碎片问题。 优点 简单易用，适用于大多数应用。 无堆内存依赖，更高效，适用于内存受限的系统或不希望使用堆的情况。 xTaskCreate 详细tracestep1 - prvCreateTask123456789101112// 只列举了必要的 tcb itemstruct tskTaskControlBlock&#123; volatile StackType_t *pxTopOfStack; /* 栈顶指针（指向栈顶） */ StackType_t *pxEndOfStack ListItem_t xStateListItem; /* 任务就绪/挂起链表中的元素（用于任务调度） */ ListItem_t xEventListItem; /* 事件等待链表元素 */ UBaseType_t uxPriority; /* 任务的优先级 */ StackType_t *pxStack; /* 任务栈的起始地址 */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /* 任务名称 */ // ... 其他与任务相关的状态信息 ...&#125;; 申请 TCB mem, 并初始化为 0 申请 stack mem, 如果 1 success prvInitialiseNewTask 初始化 tcb + stack, 初始化tcb 中的item，将stack 初始成刚从中断回归的样子（reg 排放位置不同的指令集不同） prvInitialiseNewTask 将 stack mem 填充为规律的字符串， 如 0xa5U 初始化 tcb pxTopOfStack &#x2F; tcb pxEndOfStack 12345678910 pxTopOfStack = pxNewTCB-&gt;pxStack; // 获取栈起始地址// 对齐到目标字节边界（如 4/8 字节对齐），避免硬件访问异常 pxTopOfStack = ( StackType_t * ) ( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) + portBYTE_ALIGNMENT_MASK ) &amp; ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /* Check the alignment of the calculated top of stack is correct. 断言验证对齐成功*/ configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack &amp; ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0U ) ); /* The other extreme of the stack space is required if stack checking is * performed. 保存栈空间的“顶端”地址，给栈溢出检测或栈指针初始化使用*/ pxNewTCB-&gt;pxEndOfStack = pxNewTCB-&gt;pxStack + ( uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ); 举例 ： (pxTopOfStack + portBYTE_ALIGNMENT_MASK) = 0x10003 + 0x07 = 0x1000A , 然后与 ~(0x07) = 0x1000A &amp; 0xFFFFFFF8 = 0x10008 赋值 tcb pcTaskName 规范化 uxPriority 使&lt; max priority , 并赋值 tcb uxPriority uxPriority (任务优先级)** item value &#x3D; configMAX_PRIORITIES - uxPriority 5 10 - 5 &#x3D; 5 8 10 - 8 &#x3D; 2 (值更小，排更前面) init list item ; 设定 list item owner 为 tcb, 通过 listSET_LIST_ITEM_OWNER; 设定 evt list item value 为 priority（用来之后按优先级处理evt）; xStateListItem ：用于任务所在的调度器状态队列，比如就绪队列、挂起队列、延时队列。xEventListItem ：用于事件队列，比如信号量等待队列，事件组等待队列。 init stack ~ pxPortInitialiseStack (不同的assemble code 使用的不同的恢复现场的方式，所以这里的实现也不同) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxTaskCode, void *pvParameters ) &#123; /* 假设栈是从高地址开始向下增长 */ /* 设置任务栈的内容 */ /* 初始化栈的内容，模拟从中断返回的情况 */ /* mstatus 寄存器: 设置为用户模式 */ pxTopOfStack--; /* mstatus 的位置 */ *pxTopOfStack = ( StackType_t ) 0x00000000U; /* 设置为用户模式，具体值视情况而定 */ /* pc 寄存器：程序计数器，任务的入口地址 pxTaskCode */ pxTopOfStack--; /* pc 寄存器的位置 */ *pxTopOfStack = ( StackType_t ) pxTaskCode; /* 保存其它寄存器内容，设为默认值（0 或者特定初始化值） */ for (int i = 0; i &lt; 31; i++) &#123; pxTopOfStack--; /* x0 ~ x31 寄存器的栈位置 */ *pxTopOfStack = 0; /* 默认为 0 */ &#125; /* 保存函数参数（pvParameters），即传递给任务函数的参数 */ pxTopOfStack--; /* x0 寄存器的位置 */ *pxTopOfStack = ( StackType_t ) pvParameters; /* 中断标志寄存器 mtvec, mcause, mepc 通常在调度时恢复，这里可以初始化为零 */ /* 这在实际中一般不需要，因为 FreeRTOS 主要是模拟中断返回来进行任务切换 */ /* 返回任务栈的顶部指针，栈已经初始化 */ return pxTopOfStack; &#125; /* stack 初始化后的长相，下次切换到此task后可以直接从这个现场开始run +---------------------------+ &lt;- 栈顶 (pxTopOfStack) | mstatus | &lt;- 任务的 mstatus 寄存器 (用户模式标志等) +---------------------------+ | pc (Task Code) | &lt;- 程序计数器 (指向任务入口地址) +---------------------------+ | x31 | &lt;- 寄存器 x31 (初始化为 0) +---------------------------+ | x30 | &lt;- 寄存器 x30 (初始化为 0) +---------------------------+ | ... | &lt;- 其他通用寄存器 x29, x28, ..., x1 (初始化为 0) +---------------------------+ | x0 | &lt;- 寄存器 x0 (初始化为 0) +---------------------------+ | pvParameters | &lt;- 任务的参数 pvParameters +---------------------------+ &lt;- 栈底 (pxStack) */ step2 - prvAddNewTaskToReadyListready list 结构如下图，是一个数组，数组的每个item 挂了一串同优先级的 tcb-&gt;state_item 操作了很多 global var， 所以func 基本都在屏蔽中断中run 1.uxCurrentNumberOfTasks + 1, 如 uxCurrentNumberOfTasks &#x3D; 1, 说明是 first tcb， 要init task list, 2.pxCurrentTCB, 如当前没 taks run 则 current tcb &#x3D; tcb; 否则有其他 task run 则比较优先级比的过就切(在xSchedulerRunning = false 的状况下即初始化 tasks 时候才可以这样硬切 tcb) 3.uxTaskNumber + 1, 记录所有运行过的task num 4.pxReadyTasksLists, 5.uxTopReadyPriority, 记录当前准备执行的任务的最高优先级，帮助调度器快速判断下一个应当运行的任务 task flow 1.关中断 2.uxCurrentNumberOfTasks++ 3.pxCurrentTCB &#x3D;&#x3D; NULL 则 current tcb &#x3D; task tcb, 同时如果 uxCurrentNumberOfTasks &#x3D;&#x3D; 1 则init task list 4.pxCurrentTCB !&#x3D; NULL &amp;&amp; xSchedulerRunning &#x3D;&#x3D; pdFALSE 则直接切task, current tcb &#x3D; task tcb 5.uxTaskNumber++ 6.prvAddTaskToReadyList( pxNewTCB ) ~ refresh uxTopReadyPriority, 并把 tcb-&gt;state_item 插入到 ready_list[tcb-&gt;priority] 的 list 末尾 7.开中断 8.xSchedulerRunning !&#x3D; pdFALSE，调用 portYield 切换task，新task priority 优先级可能higher ref linkhttps://wiki.csie.ncku.edu.tw/embedded/freertoshttps://www.freertos.org/","tags":[{"name":"freeRTOS","slug":"freeRTOS","permalink":"http://example.com/tags/freeRTOS/"}],"categories":[{"name":"freeRTOS","slug":"freeRTOS","permalink":"http://example.com/categories/freeRTOS/"}]},{"title":"802-15-4-phy_related","date":"2025-03-31T00:14:40.000Z","path":"wiki/802-15-4-phy-related/","text":"简单学习了 802.15.4(2015) phy layer 。 PHY servicesPHY（物理层） 通过 RF 固件 和 RF 硬件，在 MAC 子层 与 物理无线信道 之间提供接口。 PHY 组件PHY 概念上包含一个管理实体 PLME（PHY 层管理实体），其职责包括： 提供 层管理服务接口，用于调用层管理功能。 维护 PHY 层 PAN 信息库（PHY PIB），存储 PHY 相关的管理对象。 PHY 服务接口PHY 提供 两类服务，通过 两个 SAP（服务访问点） 访问： PHY 数据服务 —— 通过 PHY 数据 SAP（PD-SAP） 访问。 PHY 管理服务 —— 通过 PLME-SAP 访问。 注意：本标准未定义 PD-SAP 和 PLME-SAP，因为典型实现中不会直接暴露它们。 PHY PIB 访问 PHY PIB 属性 通过 MLME-SAP 访问，使用： MLME-GET 读取属性 MLME-SET 设置属性 常量与属性 PHY 维护的常量： 以 “a” 作为前缀，例如 aMaxPhyPacketSize（见表 11-1）。 PHY 维护的属性： 以 “phy” 作为前缀，例如 phyCurrentChannel（见表 11-2）。 特定 PHY 属性： 以 “phyHrpUwb” 为前缀的属性（如 phyHrpUwbDataRatesSupported）仅适用于 HRP UWB PHY，其他 PHY 不使用这些属性。 通用要求与定义除非另有规定，所有 PHY 层 使用 2 字节（octet） 的 FCS（帧校验序列）。 PHY 层的主要职责PHY 层负责以下任务： 激活和关闭 无线收发器 能量检测（ED）：检测当前信道的能量水平 链路质量指示（LQI）：评估接收数据包的质量 清除信道评估（CCA）：用于 CSMA-CA（载波侦听多址接入-冲突避免） 信道频率选择 数据传输与接收 精准测距（Precision Ranging）：用于 超宽带（UWB）PHY 不同 PHY 类型的 PDU 形式是否不同？不同的 PHY（物理层）类型的 PDU（协议数据单元，Protocol Data Unit）格式是不同的。IEEE 802.15.4 标准定义了多种 PHY，每种 PHY 的 帧结构、调制方式、编码方式和字段布局 都可能有所不同。 1. PDU 的基本组成通常，PHY PDU 由以下几个部分组成： SHR（同步头，Synchronization Header）： 用于接收机同步。 PHR（PHY 头部，PHY Header）： 指示帧的长度和格式。 Payload（有效载荷）： MAC 层的 MPDU（MAC Protocol Data Unit）。 FCS（帧校验序列，Frame Check Sequence）： 用于错误检测。 不同 PHY 类型可能会在这些字段的长度、格式、调制编码等方面有所不同。 2. 不同 PHY 类型的 PDU 差异 PHY 类型 调制方式 PDU 主要差异 O-QPSK PHY Offset-QPSK (DSSS) 采用 6 字节 SHR，2 字节 PHR，支持变长帧 BPSK PHY BPSK (DSSS) 采用 6 字节 SHR，2 字节 PHR，低速率但抗干扰强 ASK PHY ASK&#x2F;BPSK (PSSS) 支持更灵活的数据速率 CSS PHY Chirp Spread Spectrum SHR、PHR 长度不同，适用于远距离通信 HRP UWB PHY BPM + BPSK 短 SHR（4-8 字节），FCS 可变 SUN FSK PHY FSK 采用 可变长度 PDU，PHR 具有更多控制比特 SUN OFDM PHY OFDM 带有特殊 PHR 编码，适用于高速传输 3. 主要区别点 前导码（SHR） 长度不同，用于不同同步需求。 PHY 头（PHR） 格式不同，决定帧长、调制模式等。 有效载荷（Payload） 可能支持不同的最大长度。 FCS 校验方式：不同 PHY 可能采用 16-bit 或 32-bit FCS。 不同应用场景（如低功耗、远距离、高速率）都会影响 PHY PDU 的设计。 举例 O-QPSK PHYFormat of the PPDUPPDU &#x3D; SHR + PHR + Phy payloadSHR &#x3D; Preamble + SFDPHR &#x3D; Frame Length(0~6bits) + Reserved(7bit) O-QPSK PHY 同步头（SHR）字段 , O-QPSK（Offset Quadrature Phase Shift Keying）PHY 的同步头（SHR）用于帧同步，包含两个主要字段： Preamble 字段 , 8 个符号（即 4 字节）; 预导码字段的所有比特均为二进制 0 ; 用于接收端的位同步，确保接收机可以正确锁定信号。 SFD（Start Frame Delimiter）字段, 表示 SHR 结束，标识数据帧的起始位置, 内容如下： Bits 0 1 2 3 4 5 6 7 Value 1 1 1 0 0 1 0 1 调制与扩频O-QPSK PHY 使用一种 16 进制准正交调制技术。在每个数据符号周期中，四个信息比特用于选择 16 种几乎正交的伪随机噪声（PN）序列之一进行传输。连续的数据符号的 PN 序列被串联起来，聚合的芯片序列通过偏移正交相位移键控（O-QPSK）调制到载波上。 数据速率： 在 2450 MHz、915 MHz、780 MHz 或 2380 MHz 频段时，数据速率为 250 kb&#x2F;s。 在 868 MHz 频段时，数据速率为 100 kb&#x2F;s。 2450 MHz O-QPSK PHY 的支持： 在 2450 MHz 频段时，必须支持 O-QPSK PHY。 2380 MHz O-QPSK PHY 的支持： 在 2380 MHz 频段时，必须支持 O-QPSK PHY。 868 MHz 或 915 MHz 频段的 O-QPSK PHY： O-QPSK PHY 在 868 MHz 或 915 MHz 频段并非强制要求。 如果在这些频段使用 O-QPSK PHY，则该设备还必须能够使用 BPSK PHY 信号进行通信。 参考调制器图 bit到symbol映射 每个字节（octet）的 4 个最低有效位（LSBs） (b0, b1, b2, b3) 映射到一个数据符号 （下表的0～15）。 4 个最高有效位（MSBs） (b4, b5, b6, b7) 映射到下一个数据符号。 PPDU 的每个字节都会按顺序通过调制和扩频处理，从 前导码（Preamble）字段 开始，直到 PSDU 的最后一个字节。 在每个字节中： 最低有效符号 (b0, b1, b2, b3) 先被处理。 最高有效符号 (b4, b5, b6, b7) 后被处理。 symbol到chip映射 在 2450 MHz 和 2380 MHz 频段，每个数据符号映射到一个 32 芯片（chip） 的伪随机噪声（PN）序列。 这些 PN 序列通过循环移位（cyclic shifts）和&#x2F;或共轭（conjugation，即奇数索引的芯片值反转）相互关联。 O-QPSK 调制 芯片序列调制方式： 偶数索引芯片（even-indexed chips） 调制到 同相（I）载波。 奇数索引芯片（odd-indexed chips） 调制到 正交（Q）载波。 不同频段的符号到芯片映射： 在 2450 MHz 和 2380 MHz 频段，每个数据符号映射到 32 芯片，因此芯片速率是 符号速率的 32 倍。 在 915 MHz、868 MHz 和 780 MHz 频段，每个数据符号映射到 16 芯片，因此芯片速率是 符号速率的 16 倍。 I 相与 Q 相的时间偏移： Q 相芯片（Q-phase chips） 相对于 I 相芯片（I-phase chips） 延迟 Tc。 Tc 是芯片速率的倒数，即 Tc &#x3D; 1 &#x2F; 芯片速率。 图 12-6 说明了 I 相与 Q 相芯片调制的时间偏移关系。 Pulse shape O-QPSK PHY RF requirementsO-QPSK PHY 在以下频段内运行： 779–787 MHz 868.0–868.6 MHz 902–928 MHz 2360–2400 MHz 2400.0–2483.5 MHz 其中，2400.0–2483.5 MHz 频段（即 2.4 GHz 频段）是 O-QPSK 在 IEEE 802.15.4 标准中最常用的频段，支持 250 kbps 传输速率，并且具有全球通用性。 Transmit power spectral density (PSD) mask 符号速率 868 MHz 频段：符号速率为 25 ksymbol&#x2F;s 780 MHz、915 MHz、2380 MHz、2450 MHz 频段：符号速率为 62.5 ksymbol&#x2F;s 速率精度：± 40 × 10⁻⁶ 接收灵敏度 在 10.1.7 规定的测试条件下，符合标准的设备应具备 -85 dBm 或更优 的接收灵敏度。","tags":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/tags/802-15-4/"}],"categories":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/categories/802-15-4/"}]},{"title":"802.15.4-mac_services","date":"2025-03-27T00:35:47.000Z","path":"wiki/802-15-4-mac-services/","text":"介绍了 802.15.4(2015) mac layer services, 包括 genernal review mlme &#x2F; mcps &#x2F; mac constans &amp;&amp; mac pib 。 MAC 层（媒体访问控制层）负责协调设备之间的无线通信，并分为两个主要部分： 1. MAC 层管理实体（MLME, MAC Layer Management Entity） 2. MAC 公共部分子层（MCPS, MAC Common Part Sublayer） SAP 的概念在 IEEE 802.15.4 标准中，SAP（服务访问点） 是不同协议层之间的接口，用于数据传输和管理控制。SAP 允许协议栈的不同层之间交换数据和命令，例如 MCPS-SAP 和 MLME-SAP。 SAP 的作用在协议栈中，不同层的功能不同，而 SAP 作为接口，提供标准化的交互方式，例如： 应用层 ↔️ 网络层 通过 NLDE-SAP（网络层数据实体 SAP） 交换数据。 网络层 ↔️ MAC 层 通过 NLME-SAP（网络层管理实体 SAP） 进行管理操作。 MAC 层 ↔️ 物理层 通过 PLME-SAP（物理层管理实体 SAP） 进行通信。 802.15.4 中常见的 SAP SAP 名称 作用 涉及层 MCPS-SAP（MAC Common Part Sublayer Service Access Point） 处理 MAC 层数据传输 MAC 层 ↔️ 上层 MLME-SAP（MAC Layer Management Entity Service Access Point） 处理 MAC 层管理功能（如信标、关联） MAC 层 ↔️ 上层 PLME-SAP（Physical Layer Management Entity Service Access Point） 物理层管理（如信道设置） 物理层 ↔️ MAC 层 PD-SAP（Physical Data Service Access Point） 物理层数据传输 物理层 ↔️ MAC 层 SAP 的工作方式SAP 主要通过以下方式进行交互： ind + resp ; req + confirm Indication（指示）：下层通知上层某个事件发生（如收到数据）。 Response（响应）：上层对某个请求的回应（如关联请求的确认）。 Request（请求）：上层请求下层执行某项操作（如发送数据）。 Confirm（确认）：下层反馈请求的执行结果（如数据发送成功或失败）。 SAP 示例（MCPS-DATA 发送流程）假设一个设备要发送数据，SAP 交互流程如下： 上层调用 MCPS-DATA.request，请求 MAC 层发送数据。 MAC 层处理 该请求，并通过物理层发送数据。 如果对方收到数据并回复 ACK，MAC 层生成 MCPS-DATA.confirm 反馈给上层，表示发送成功。 如果对方未响应，MAC 层可能会重传，最终给出 MCPS-DATA.confirm，通知上层发送成功或失败。 MLME primtivesMLME-SAP（MAC 层管理实体服务访问点）接口用于上层与 MAC 层之间的管理交互。它提供了一系列的 原语（primitives），用于执行网络管理、配置以及控制操作。包括设备的加入&#x2F;退出网络、扫描、同步、参数设置、信标通知等。这些原语是 MAC MLME 的核心部分，帮助设备与网络协调工作，确保 PAN 的正常运行。 common 情况处理(MLME 处理 higher layer 内容时出现问题)错误处理（Request（请求）） 如果在 请求原语 的 发送帧安全处理（如 9.2.1 所述）中发生任何错误，MLME 会丢弃该帧，并使用相应的确认原语，返回 发送帧安全处理 中的错误。 错误处理（Response（响应）） 如果在 响应原语 的 发送帧安全处理（如 9.2.1 所述）中发生任何错误，MLME 会丢弃该帧，并使用 MLME-COMM-STATUS.indication 原语，返回 发送帧安全处理 中的错误。 参数无效或超出范围 如果 请求原语 中的任何参数不受支持或超出范围，MAC 子层 会使用 INVALID_PARAMETER 状态值返回相应的确认原语。 如果 响应原语 中的任何参数不受支持或超出范围，MAC 子层 会使用 INVALID_PARAMETER 状态值返回 MLME-COMM-STATUS.indication 原语。 CSMA-CA 失败 如果由于 CSMA-CA 算法失败，MLME 无法发送 请求原语 所需的帧，MLME 会使用 CHANNEL_ACCESS_FAILURE 状态值返回相应的确认原语。 ACK 未收到 如果 MLME 成功发送 请求原语 所需的帧，但没有收到预期的确认帧，MLME 会使用 NO_ACK 状态值返回相应的确认原语。 关键MLME原语 MLME-ASSOCIATE: 设备请求加入网络时使用此原语。包含关联请求、确认、指示和响应。设备通过该原语与 PAN 协调器建立连接。 MLME-SCAN: 该原语用于启动扫描操作，寻找可用的 PAN 网络。可以进行主动扫描（发送探测请求）或被动扫描（接收信标）。 MLME-SYNC: 该原语用于设备与协调器之间的同步，确保设备与网络的时序同步。 MLME-START: 该原语用于协调器启动或重新启动一个 PAN，分配新的 PAN ID，并开始信标传输。 MLME-BEACON-NOTIFY: 设备接收到 PAN 协调器的信标时使用此原语，通知设备信标信息，如网络同步信息和协作参数。 MLME-PROMISCUOUSMODE: 该原语允许设备进入混杂模式，即设备可以接收所有频段上的数据包，而不仅仅是属于其自己 PAN 的数据包。 MLME-SET 和 MLME-GET: 这两个原语用于配置和查询 MAC 层的参数，例如 PAN ID、信标周期、重试次数等。 举例MLME-ASSOCIATE.request mlme primitive 类似于 bluetooth 的 hci cmd / hci evt，去进行一些 mac layer 控制管理 ，在802.15.4 中都有详细的参数描述解释定义。下面举例MLME-ASSOCIATE.request： MLME-ASSOCIATE.request 原语详细解析在 IEEE 802.15.4 标准中，MLME-ASSOCIATE.request 是一个用于设备请求加入 PAN 网络 的原语。设备通过该原语向 MAC 层请求与 PAN 协调器 建立关联。 MLME-ASSOCIATE.request 的参数 MLME-ASSOCIATE.request 原语包含以下主要参数： 参数名称 描述 deviceAddress 设备的地址，通常是设备的 MAC 地址。可以是 短地址（16位）或 扩展地址（64位）。 capabilityInformation 设备的能力信息，用来表示设备是否支持某些功能（例如，是否支持 FFD（Full Function Device）或 RFD（Reduced Function Device）等）。 securityLevel 表示安全级别，指明通信过程中使用的加密方式及密钥管理。 pansId 指定目标 PAN 的 PAN ID。设备需要指定与之关联的 PAN。 assocDeviceAddress 设备的目标关联设备的地址。设备会尝试与此地址对应的 PAN 协调器建立联系。 MLME-ASSOCIATE.request 的执行流程 当 MLME-ASSOCIATE.request 被发出时，MAC 层会按照以下步骤执行： 参数验证MAC 层首先验证原语中的 参数，例如设备地址、能力信息等是否合理。如果参数无效，原语将失败。 访问权限检查MAC 层会根据设备的类型（如 FFD 或 RFD）和能力信息，决定是否允许设备与目标 PAN 协调器建立连接。FFD 可以充当 PAN 协调器，而 RFD 只能与 FFD 设备建立连接。 发送关联请求如果验证通过，MAC 层将构造一个 关联请求帧（Association Request Frame）。该帧包含设备的地址、能力信息等数据，然后发送到目标 PAN 协调器。 等待响应协调器收到请求后，会通过 MLME-ASSOCIATE.response 原语向设备响应，表明关联是否成功。如果成功，设备将被分配一个 PAN 地址（如果是新的设备）。 关联成功或失败 如果关联成功，MAC 层会使用 MLME-ASSOCIATE.confirm 向上层发送确认，表示设备已经成功加入网络。 如果失败，MAC 层会发送失败指示（例如，因 PAN ID 不匹配或设备能力不符合要求）。 与 PIB（Protocol Information Base）的关系 在 MLME-ASSOCIATE.request 执行时，PIB（协议信息库）中的相关参数起着重要作用。PIB 包含与设备配置和网络管理相关的所有信息，以下是几个可能影响关联过程的 PIB 项目： macPANId设备将会通过 MLME-ASSOCIATE.request 中的 pansId 参数向目标协调器发起关联请求，PIB 中的 macPANId 必须与请求的 PAN ID 匹配。 macShortAddress 和 macExtendedAddress设备的地址会通过 deviceAddress 参数传递。MAC 层会根据 PIB 中存储的设备地址信息来处理设备的身份验证与连接。 macAssociationPermit如果 PIB 中的 macAssociationPermit 为 FALSE，即禁用关联，MAC 层会拒绝设备的关联请求。 macBeaconOrder如果设备在扫描过程中检测到的信标符合其 macBeaconOrder（信标周期）配置，MAC 层才会继续发送关联请求。 macDeviceType设备的类型（FFD 或 RFD）通过 capabilityInformation 参数传递。PIB 中的 macDeviceType 会影响设备是否能成功加入网络。 MCPS primtivesMAC 数据服务（MAC Data Service）通过 MCPS（MAC 层数据服务）接口提供了数据传输的基本功能 功能 发送数据：用于将数据从发送方传输到接收方。数据传输可以通过 点对点通信 或 广播 进行。 接收数据：MAC 层也能够处理从物理层接收到的数据包，将其传递给上层。 保证数据的可靠性：MAC 层通过重新传输机制、确认机制来保证数据的传输可靠性。 传输类型 数据帧：通过数据服务传输的基本单元是数据帧（Data Frame），包括数据的有效载荷、目的地址、源地址等信息。 确认（ACK）帧：用于确认数据帧的接收。 MCPS 原语 MCPS-DATA.request：请求发送数据帧。 MCPS-DATA.confirm：确认数据发送的结果。 MCPS-DATA.indication：通知上层接收到的数据帧。 Purging 操作 MCPS-PURGE.request：请求清除数据队列中的未成功发送的数据帧。 MCPS-PURGE.confirm：确认是否成功清除数据队列中的数据帧。 举例MCPS-DATA.request在 IEEE 802.15.4 中，MCPS-DATA.request 是用于请求发送数据帧的原语。 1. MCPS-DATA.request 参数解析 MCPS-DATA.request 原语的参数通常包括以下内容： 参数名称 描述 dstAddr 目标设备地址，通常为 短地址 或 扩展地址。可以是单播地址或广播地址。 srcAddr 源设备地址，通常为发送设备的 短地址 或 扩展地址。 frame 要发送的数据帧，其中包括数据的有效载荷、目的地址、源地址等信息。 securityLevel 数据传输的安全级别，指示是否进行加密、验证等。此字段可以影响数据发送的安全性。 ackRequired 是否要求接收方返回确认帧（ACK）。如果为 true，MAC 层将等待接收方的 ACK 响应。 txOptions 传输选项，可以指定数据帧发送的额外特性（例如是否为广播帧等）。 2. MCPS-DATA.request 执行流程 2.1 数据准备 当上层应用或协议栈调用 MCPS-DATA.request 请求发送数据时，MAC 层会进行以下准备工作： 验证请求参数：检查目标地址、源地址等字段是否有效。 构建数据帧：根据请求中的 frame 和其他参数构建数据帧。该数据帧包括了源地址、目标地址、有效载荷、序列号等信息。 检查安全性设置：根据 securityLevel 参数，MAC 层会决定是否进行数据加密或认证。 2.2 与 PIB（协议信息库）的关系MAC 层会查询 PIB（Protocol Information Base） 来获取与数据发送相关的配置信息。PIB 中的一些关键参数影响数据的发送过程： macPANId：用于判断数据是否属于目标 PAN。如果数据的 dstAddr 与 macPANId 不匹配，发送操作将失败。 macShortAddress 和 macExtendedAddress：这些字段用于构建源地址和目标地址，特别是设备的 16 位或 64 位地址。 macAckWaitDuration：控制数据帧等待 ACK 响应的时间。如果 ackRequired 为 true，MAC 层会使用该配置项来设置等待 ACK 的最大时长。 macMaxFrameRetries：如果数据发送失败，MAC 层会尝试重新发送。此参数指定最大重试次数。 macMaxFrameSize：控制单个数据帧的最大大小。如果数据帧超过最大帧大小，MAC 层可能会将数据进行分段。 2.3 数据帧的发送 物理层发送：MAC 层会将构建好的数据帧交给物理层进行发送。物理层负责将数据转换为无线信号并传输。 2.4 确认机制 如果 ackRequired 为 true，MAC 层会等待接收方发送 ACK 帧作为确认。如果在指定时间内没有收到 ACK，MAC 层会根据 PIB 中的 macMaxFrameRetries 设置重试次数，直到成功或超出最大重试次数。 2.5 发送确认 如果数据成功发送，MAC 层会通过 MCPS-DATA.confirm 向上层应用发送数据发送成功的确认。 如果发送失败（例如超时或重试次数用尽），MAC 层会通知上层失败原因。 MAC constants &amp;&amp; PIB在 IEEE 802.15.4 标准中，MAC（Medium Access Control）层使用一些常量和 PIB（Protocol Information Base）属性来控制和配置设备的行为。常量用于设置 MAC 层操作的参数范围，而 PIB 属性则保存设备的配置和状态信息。以下是 MAC 常量 和 PIB 属性 的详细说明。 1. MAC 常量 1.1 常量概述MAC 常量是预定义的常量值，用于指定在 MAC 层操作中使用的各种参数。例如，这些常量用于数据传输、重试次数、最大帧大小等。它们定义了 MAC 层的一些行为规范。 1.2 常见的 MAC 常量 常量名称 描述 MAC_MAX_FRAME_RETRIES 最大帧重试次数。指定在发送数据时，MAC 层允许的最大重试次数。默认值为 3。 MAC_ACK_WAIT_DURATION 等待确认的时间（单位：符号时间），指定了设备在发送数据后，最多等待多少符号时间以接收 ACK。 MAC_MAX_FRAME_SIZE 最大数据帧大小。指定了数据帧的最大长度（以字节为单位）。 MAC_PAN_ID PAN（Personal Area Network）ID，指定设备所属的 PAN 标识符。 MAC_BROADCAST_ADDR 广播地址。通常用于广播数据包。 MAC_SECURITY_ENABLED 安全功能启用标志。如果为 true，表示启用安全功能（如加密和认证）。 MAC_FRAME_TYPE_DATA 数据帧类型常量。指定该数据帧是数据传输帧。 MAC_FRAME_TYPE_ACK 确认帧类型常量。指定该数据帧是 ACK 确认帧。 1.3 常量用途这些常量定义了设备的行为规范，例如： MAC_MAX_FRAME_RETRIES 控制最大重试次数，确保设备不会因为多次发送失败而进入无限重试状态。 MAC_ACK_WAIT_DURATION 确定了设备在发送数据后等待确认的时间，这对于网络中的数据传输延迟控制至关重要。 MAC_SECURITY_ENABLED 则控制设备是否使用加密和认证机制，提高数据传输的安全性。 2. PIB 属性 2.1 PIB 概述PIB（Protocol Information Base）是一个存储协议配置信息的数据库。它保存了与 MAC 层的操作相关的各种配置和状态信息。PIB 属性用于配置设备的 MAC 层行为，并在设备运行时进行修改和读取。 2.2 常见的 PIB 属性 属性名称 描述 macShortAddress 设备的短地址（16 位）。用于标识设备在同一 PAN 内的唯一性。 macExtendedAddress 设备的扩展地址（64 位），在 PAN 内唯一标识设备。 macPANId PAN 的标识符，设备所属的个人区域网络的 ID。 macBeaconOrder 信标周期的周期性参数，指示设备发射信标的频率。 macSuperframeOrder 超帧顺序，决定设备在网络中活动时使用的时间段。 macMaxFrameRetries 数据传输失败后的最大重试次数。 macMaxCSMABackoffs 在发送数据之前，设备允许的最大退避次数，用于避免碰撞。 macSecurityMode 安全模式，指示是否启用加密和认证。 macRxOnWhenIdle 设备是否在空闲时保持接收模式。如果为 true，设备即使在空闲时也能接收数据。 macMaxFrameSize 允许的最大数据帧大小。 macAckWaitDuration 等待确认的最大时间（符号时间单位）。 macTransactionPersistenceTime 事务持久化时间，指示在事务期间内设备可以保持数据传输状态。 2.3 PIB 属性用途PIB 属性用于控制和配置设备在 MAC 层 上的行为。下面是一些常见的 PIB 属性及其应用： macShortAddress 和 macExtendedAddress：用于设备地址的标识。短地址通常用于快速数据传输，而扩展地址用于全局唯一的标识。 macPANId：用于标识设备所属的网络。PAN ID 是设备加入网络的关键参数，确保设备可以识别网络并与其他设备进行通信。 macMaxFrameRetries：控制重试次数，确保数据的可靠传输。 macSecurityMode：确定是否启用安全特性（如加密和认证），保证数据的安全性。 macMaxCSMABackoffs：控制发送失败后的退避次数，用于减少碰撞并提高传输效率。 2.4 PIB 和 MAC 常量的关系许多 PIB 属性 实际上是由 MAC 常量 决定的。例如，macMaxFrameRetries 和 MAC_MAX_FRAME_RETRIES 常量是相互关联的。常量用于设置默认值，而 PIB 属性用于在运行时修改和读取设备的配置。 3. PIB 属性的访问与修改 3.1 读取和设置 PIB 属性设备可以通过特定的接口来读取和修改 PIB 属性。例如，设备可以通过 MLME（MAC Layer Management Entity）接口来设置或获取 PIB 属性。 示例：设置 PIB 属性 MLME_SET.request &#123; pibAttribute: macShortAddress, pibAttributeValue: 0x1234 &#125;","tags":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/tags/802-15-4/"}],"categories":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/categories/802-15-4/"}]},{"title":"hexo github.io image 显示异常","date":"2025-03-25T23:53:42.000Z","path":"wiki/hexo-image-sync-my-solution/","text":"在使用 hexo 写 blog 插入图片时，大多数会使用 typora&#x2F;markdown allin one 等去 preview，此时的(preview) img path 是相对 source&#x2F;_posts&#x2F;**.md 文档的路径；而 github.io 静态页面展示图片是要使用public 为 root path 的路径引用图片；路径不match 会导致图片显示异常，网上也有很多的案例和解法，使用起来感觉始终不顺手，在这里放上我的解法。 1.创建如下目录结构：blog/source/images , blog/public/images , blog/sync.py 2.编辑 **.md 并想要预览时，请插入类似下面的图片链接 1&lt;center&gt;&lt;img src=&quot;/../images/802-15-4-mac-frm/4_beacon_frm.png&quot; width=&quot;800px&quot;&gt;&lt;/center&gt; 3.完成编辑后在 blog folder 下运行 python3 sync.py add sync, 会将 source/images 下 img sync 到 public/imgs, 同时将所有 **.md 中的图片链接前加“/”转为如下，使可以在github.io上显示 1&lt;center&gt;&lt;img src=&quot;/../images/802-15-4-mac-frm/4_beacon_frm.png&quot; width=&quot;800px&quot;&gt;&lt;/center&gt; 4.运行 python3 sync.py add sync 后 md preview 将无法正常显示图片，如果想重新编辑可以再运行 python3 sync.py remove 即可 5.我的上blog step: python3 sync.py add sync -> hexo c -> hexo g -> hexo d **下面附上sync.py的code，这个是请教chatgpt帮忙写的** 命令 作用 python sync_and_modify.py sync 仅同步 source/images 到 public/images python sync_and_modify.py add 仅增加 Markdown 中 img src 里的 / python sync_and_modify.py sync add 同步图片 + 增加 / python sync_and_modify.py remove 仅去掉 Markdown 中 img src 里的 /（单独执行） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import osimport shutilimport reimport sysdef sync_folders(src, dest): &quot;&quot;&quot; 同步 source/images 到 public/images，确保文件和目录保持一致。 &quot;&quot;&quot; if not os.path.exists(src): print(f&quot;源目录 &#123;src&#125; 不存在！&quot;) return if not os.path.exists(dest): os.makedirs(dest) # 如果目标文件夹不存在，则创建 for root, dirs, files in os.walk(src): rel_path = os.path.relpath(root, src) target_dir = os.path.join(dest, rel_path) if not os.path.exists(target_dir): os.makedirs(target_dir) for file in files: src_file = os.path.join(root, file) dest_file = os.path.join(target_dir, file) if not os.path.exists(dest_file) or os.path.getmtime(src_file) &gt; os.path.getmtime(dest_file): shutil.copy2(src_file, dest_file) print(f&quot;同步文件: &#123;src_file&#125; -&gt; &#123;dest_file&#125;&quot;) print(&quot;图片同步完成！&quot;)def modify_image_paths_in_markdown(posts_folder, mode): &quot;&quot;&quot; 遍历 source/_posts 目录下所有 .md 文件，修改 img 标签中的 src 路径。 参数: posts_folder: Markdown 文件所在目录（如 source/_posts） mode: &quot;remove_slash&quot; -&gt; 移除 img src 里开头的 &quot;/&quot; &quot;add_slash&quot; -&gt; 给 img src 里开头增加 &quot;/&quot; &quot;&quot;&quot; if not os.path.exists(posts_folder): print(f&quot;Markdown 目录 &#123;posts_folder&#125; 不存在！&quot;) return # 正则匹配 `&lt;img src=&quot;...&quot;` 语法 pattern_remove_slash = re.compile(r&#x27;(&lt;img src=&quot;)/(\\.\\./images/[^&quot;]+&quot;)&#x27;) pattern_add_slash = re.compile(r&#x27;(&lt;img src=&quot;)(\\.\\./images/[^&quot;]+&quot;)&#x27;) modified_files = 0 for filename in os.listdir(posts_folder): if filename.endswith(&quot;.md&quot;): file_path = os.path.join(posts_folder, filename) with open(file_path, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: content = f.read() # 根据模式修改 if mode == &quot;remove_slash&quot;: new_content = pattern_remove_slash.sub(r&#x27;\\1\\2&#x27;, content) elif mode == &quot;add_slash&quot;: new_content = pattern_add_slash.sub(r&#x27;\\1/\\2&#x27;, content) else: print(f&quot;未知模式：&#123;mode&#125;&quot;) return # 如果内容发生变化，则写入文件 if content != new_content: with open(file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(new_content) print(f&quot;已修改文件: &#123;filename&#125;&quot;) modified_files += 1 print(f&quot;Markdown 文件路径修改完成，共修改 &#123;modified_files&#125; 个文件！&quot;)def main(): # 设置文件夹路径 source_images = &quot;source/images&quot; public_images = &quot;public/images&quot; markdown_folder = &quot;source/_posts&quot; # 解析命令行参数 args = set(arg.lower() for arg in sys.argv[1:]) if not args: print(&quot;用法: python sync_and_modify.py [sync] [add] | remove&quot;) sys.exit(1) if &quot;remove&quot; in args and len(args) &gt; 1: print(&quot;错误：remove 只能单独执行，不能与 sync 或 add 组合！&quot;) sys.exit(1) if &quot;sync&quot; in args: sync_folders(source_images, public_images) if &quot;add&quot; in args: modify_image_paths_in_markdown(markdown_folder, mode=&quot;add_slash&quot;) if &quot;remove&quot; in args: modify_image_paths_in_markdown(markdown_folder, mode=&quot;remove_slash&quot;)if __name__ == &quot;__main__&quot;: main()","tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}],"categories":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"}]},{"title":"802.15.4-mac_frm_general_review","date":"2025-03-10T11:23:52.000Z","path":"wiki/802-15-4-mac-frm/","text":"主要介绍了 802.15.4 mac layer pdu 形式与各 bit 含义, 及各 field 内容 General MAC frame format frm control Bits 0–2 3 4–5 6 7 8 9 10–11 12–13 14–15 Field Frame Type Security Enabled Frame Pending AR PAN ID Compression Reserved Sequence Number Suppression IE Present Destination Addressing Mode Frame Version mac frm type b2 b1 b0 Description 0 0 0 Beacon 0 0 1 Data 0 1 0 Acknowledgment 0 1 1 MAC command 1 0 0 Reserved 1 0 1 Multipurpose 1 1 0 Fragment or Fraka 1 1 1 Extended Security Enabled 字段解析字段功能Security Enabled 字段用于指示 MAC 子层是否对该帧进行了安全保护。 Security Enabled 值 作用 1 启用 MAC 层安全保护，帧头包含Auxiliary Security Header 0 未启用安全保护，帧头不包含Auxiliary Security Header Frame Pending 字段解析字段功能Frame Pending 字段用于指示发送设备是否有更多数据等待发送给接收设备。 Frame Pending 值 作用 1 发送设备仍有待发送的数据，接收设备应继续监听 0 发送设备无待发送数据，接收设备可进入低功耗模式 适用场景信标帧（Beacon Frame） 仅在信标帧（Beacon Frame）或在 信标使能 PAN（beacon-enabled PAN）内的 CAP 时段 发送的数据帧中使用。 在 非信标使能 PAN（nonbeacon-enabled PAN）中，可在任意时间使用该字段。 低能耗（LE）CSL 模式 若 Frame Pending = 1，表示发送设备仍有数据，并期望接收设备保持射频（RF）开启，直到 Frame Pending 变为 0。 TSCH 模式 若 Frame Pending = 1，表示接收设备在 下一时隙（timeslot） 仍需保持在线，并在相同信道等待数据（若当前无调度的链路）。 其他情况 除上述情况外，Frame Pending 字段在 发送时应始终设为 0，接收时应忽略该字段。 AR 字段解析字段功能AR（Acknowledgment Request，确认请求）字段用于指定接收设备在收到数据帧（Data Frame）或 MAC 命令帧（MAC Command Frame）后，是否需要发送确认帧（Ack Frame）。 字段规则 AR 值 是否需要 Ack 适用场景 1 需要 关键数据，MAC 命令，可靠传输 0 不需要 广播帧，非关键数据，低功耗场景 AR 字段的影响提高传输可靠性启用 AR，发送设备可以确保数据成功到达，否则会进行重传（如果支持）。 降低能耗关闭 AR 可以减少额外的 Ack 传输，从而降低设备功耗，适用于低功耗 IoT 设备。 优化信道占用在高流量网络中，避免不必要的 Ack，可以减少信道竞争，提高整体通信效率。 PAN ID Compression 字段解析字段作用PAN ID Compression 字段用于指示 PAN ID（个人区域网络标识） 是否包含在 MAC 帧中，以减少数据开销。 解析规则 当 帧版本（Frame Version）字段值 为 0b00 或 0b01 时： 同时包含目标地址和源地址时： 若 目标 PAN ID 与源 PAN ID 相同，则 PAN ID Compression 设为 1，省略 Source PAN ID 字段。 若 目标 PAN ID 与源 PAN ID 不同，则 PAN ID Compression 设为 0，同时包含 Destination PAN ID 和 Source PAN ID 字段。 仅包含目标地址或源地址时： PAN ID Compression 设为 0，并且该地址的 PAN ID 字段必须包含在 MAC 帧中。 当 帧版本字段值 为 0b10 时： PAN ID Compression 字段的具体设置取决于 信标帧（Beacon Frame）、数据帧（Data Frame）、MAC 命令帧（MAC Command Frame）和确认帧（Ack Frame） 的地址格式，并遵循 表 7-2 规定的组合方式。 任何不符合 表 7-2 规定的组合方式不应生成。 Destination Address Source Address Destination PAN ID Source PAN ID PAN ID Compression Not Present Not Present Not Present Not Present 0 Not Present Not Present Present Not Present 1 Present Not Present Present Not Present 0 Present Not Present Not Present Not Present 1 Not Present Present Not Present Present 0 Not Present Present Not Present Not Present 1 Extended Extended Present Not Present 0 Extended Extended Not Present Not Present 1 Shorta Shorta Present Present 0 Shorta Extended Present Present 0 Extended Shorta Present Present 0 Shorta Extended Present Not Present 1 Extended Shorta Present Not Present 1 Shorta Shorta Present Not Present 1 总结 PAN ID Compression 值 含义 1 目标 PAN ID 与源 PAN ID 相同，省略 Source PAN ID 0 目标 PAN ID 与源 PAN ID 不同，需包含 Destination PAN ID 和 Source PAN ID 该字段的使用可以有效减少 MAC 帧长度，优化网络通信效率。📡 Sequence Number Suppression 字段字段作用Sequence Number Suppression 字段用于指示是否压制帧中的 Sequence Number（序列号） 字段。 Sequence Number Suppression 值 含义 1 序列号字段被压制，省略序列号 0 序列号字段存在 特殊情况： 如果 Frame Version（帧版本）字段 的值为 0b00 或 0b01，则 Sequence Number Suppression 字段必须为 0，即 序列号字段必须存在。 IE Present 字段字段作用IE Present 字段用于指示帧中是否包含 Information Elements (IEs)。 IE Present 值 含义 1 帧中包含 IEs 0 帧中不包含 IEs 特殊情况： 如果 Frame Version（帧版本）字段 的值为 0b00 或 0b01，则 IE Present 字段必须为 0，即帧中不包含 IEs。 此字段的设置对于确定帧的内容和处理方式非常重要。📦 Destination Addressing Mode 字段字段作用Destination Addressing Mode 字段用于指定帧的目标地址模式。此字段的值可以根据不同的帧类型和版本来决定帧的地址格式。 解析规则 Destination Addressing Mode 字段应设置为 Table 7-3 中列出的值之一。 如果 Destination Addressing Mode 字段的值为 0 且 Frame Type（帧类型）字段 指定为 Data frame 或 MAC command 且 Frame Version（帧版本）字段 为 0b00 或 0b01： Source Addressing Mode（源地址模式）字段 必须为非零值，表示帧是发送给 PAN coordinator，并且帧中的 Source PAN ID 字段指定了 PAN ID。 对于帧版本为 0b10 的情况： Destination Address 或 Destination PAN ID 或两者可能会被省略。 b1 b0 Description 0 0 PAN ID and address fields are not present. 0 1 Reserved 1 0 Address field contains a short address (16 bit). 1 1 Address field contains an extended address (64 bit). 总结 Destination Addressing Mode 值 含义 0 指定源地址信息，并且帧是发送给 PAN 协调器。 其他值 由 Table 7-3 定义，决定目标地址模式。 此字段定义了如何在数据帧中表示目标地址，影响帧的传输和处理。📡 Frame Version 字段字段作用Frame Version 字段是一个无符号整数，用于指定与帧对应的版本号。所有帧类型都应按照各自子条款中描述的方式设置 Frame Version 字段。 版本总结 Frame Version 字段决定了帧的版本号。 每种帧类型有不同的版本号要求，这些要求在 Table 7-4 中进行了总结。 版本适用性每个帧类型的适用版本总结如下： Frame Version 适用的帧类型 0b00 适用于特定帧类型，具体请参考 Table 7-4 0b01 适用于特定帧类型，具体请参考 Table 7-4 0b10 适用于特定帧类型，具体请参考 Table 7-4 Frame Type Frame Version 0b00 Frame Version 0b01 Frame Version 0b10 Frame Version 0b11 Beacon IEEE Std 802.15.4-2003 IEEE Std 802.15.4-2006 IEEE Std 802.15.4 Reserved Data IEEE Std 802.15.4-2003 IEEE Std 802.15.4-2006 IEEE Std 802.15.4 Reserved Acknowledgment IEEE Std 802.15.4-2003 IEEE Std 802.15.4-2006 IEEE Std 802.15.4 Reserved MAC Command IEEE Std 802.15.4-2003 IEEE Std 802.15.4-2006 IEEE Std 802.15.4 Reserved Reserved — — — — Multipurpose IEEE Std 802.15.4 Reserved Reserved Reserved Fragment Frame Version field not present in frame Frame Version field not present in frame Frame Version field not present in frame Frame Version field not present in frame Extended Frame Version field not present in frame Frame Version field not present in frame Frame Version field not present in frame Frame Version field not present in frame Source Addressing Mode field Source Addressing Mode 字段的值应设置为 Table 7-3 中列出的值之一。 当该字段为 0 且 Frame Type 字段指定为 Data frame 或 MAC command，并且 Frame Version 字段为 0b00 或 0b01，则 Destination Addressing Mode 字段必须为非零。 这种情况下，意味着该帧源自 PAN coordinator，其 PAN ID 由 Destination PAN ID 字段指定。 Sequence Number field Sequence Number 字段用于指定该帧的序列标识符。 对于 Beacon frame，该字段指定 BSN (Beacon Sequence Number)。 对于其他帧，该字段指定 DSN (Data Sequence Number)。 Destination PAN ID field Destination PAN ID 字段（如果存在）是一个无符号整数，指定目标设备所在的 PAN ID。 如果该字段的值为 广播 PAN ID（定义见 6.1），则所有当前监听该信道的设备都将其视为有效 PAN ID。 Destination Address field Destination Address 字段（如果存在）用于指定帧的接收者地址。 其长度由 Frame Control 字段的 Destination Addressing Mode（见 7.2.1.8）决定。 如果该字段的值为 广播短地址（定义见 6.1），则所有当前监听该信道的设备都将其视为有效地址。 该字段仅在 Destination Addressing Mode 字段非零时才包含在 MAC 帧中。 Source PAN ID field Source PAN ID 字段（如果存在）用于指定该帧的发送者所属于的 PAN ID。 设备的 PAN ID 初始由其加入 PAN 时决定，但可能会因 PAN ID 冲突解决（见 6.3.2）而发生变化。 Source Address field Source Address 字段（如果存在）用于指定该帧的发送者地址。 该字段仅在 Source Addressing Mode 字段非零时才包含在 MAC 帧 中。 Auxiliary Security Header field Auxiliary Security Header 字段包含用于 安全处理 所需的信息。 该字段仅在 Security Enabled 字段设为 1 时才会存在。 Auxiliary Security Header 字段的格式详见 9.4。 IE Field IE（Information Element）字段 为可变长度，包含一个或多个 IE。 由 Header IE 和 Payload IE 子字段组成。 该字段仅在 Frame Control 字段中的 IE Present 设为 1 时才会存在。 每个 IE 由 描述符（descriptor） 和 可选负载（optional payload） 组成，具体描述见 7.4。 Header IE Header IE（如果存在）位于 Auxiliary Security Header 之后，属于 MHR（MAC Header）。 Payload IE Payload IE（如果存在）位于 MHR 之后，属于 MAC payload，即 Payload IE 可能被加密。 Octets Variable … Variable 0&#x2F;2 Variable … Variable 0&#x2F;2 Field Header IE #1 … Header IE #n Header Termination IE Payload IE #1 … Payload IE #m Payload Termination IE 7.2.9 Frame Payload Field Frame Payload 字段 包含特定于各帧类型的信息。 如果 Security Enabled 字段设为 1，则 Frame Payload 可能受到 加密保护，详见 Clause 9。 7.2.10 FCS Field FCS（Frame Check Sequence）字段 包含一个 16-bit ITU-T CRC 或 32-bit CRC（符合 ANSI X3.66-1979.13）。 FCS 计算范围 包括 MHR 和 MAC Payload，统称为 计算字段（Calculation Field）。 兼容 SUN PHYs 或 TVWS PHYs 的设备必须实现 4-octet FCS。 7.4.1 IE List Termination说明 在确定 Header IEs 或 Payload IEs 是否需要终止时，不考虑 认证或加密过程。 下面的table 规定了 terminate IE ： HT1（Header Termination 1 IE），定义见 7.4.2.17。 HT2（Header Termination 2 IE），定义见 7.4.2.18。 注意事项 Header Termination IE 必须出现在 Payload IEs 之前，因为 Header IEs 和 Payload IEs 共享地址空间，无法直接区分二者的边界。因此，需要使用 Header Termination IE 来标识 Header IEs 的结束 和 Payload IEs 的开始。 Header IEs Present Payload IEs Present Data Payload Present Header Termination IE Included Payload Termination IE Included Notes No No No None None No IE lists present, hence no termination. Included here for completeness. Yes No No None None No termination is required because the end of the frame can be determined from the frame length and FCS length. No Yes No HT1 required Optional Header Termination IE 1 is required to signal end of the MHR and beginning of the Payload IE list. Yes Yes No HT1 required Optional Header Termination IE 1 is required while the Payload IE Termination is not required, but is allowed. No No Yes None None No IE lists present, hence no termination. Included here for completeness. Yes No Yes HT2 required None Header Termination IE 2 is used to signal end of the MHR and beginning of the MAC Payload. No Yes Yes HT1 required Required — Yes Yes Yes HT1 required Required — header ieHT1 &#x2F; HT2 ie 也使用了下表的格式，只不过 content len &#x3D; 0, ElementID &#x3D; 0x7E&#x2F;7F; Element ID 的使用，直接就代表了具体的 header ie, 而 payload IE 中的 Group ID 则代表了更多无限的可能 ～ Group 下还有 Nest IE ～ sub-ID Bits 0–6 7–14 15 0–127 Field Length Element ID Type &#x3D; 0 Content payload ie Bits 0–10 11–14 15 0–2047 Field Length Group ID Type &#x3D; 1 Content nested short&#x2F;long ie ~ payload ie ~ group Id &#x3D; mlme(0x1)nested ie 下又分出了很多 sub id ie Bits 0–7 8–14 15 0–255 Field Length Sub-ID Type &#x3D; 0 Content Bits 0–10 11–14 15 0–2047 Field Length Sub-ID Type &#x3D; 0 Content 主要介绍了 802.15.4 具体的 frm type 对应的 mac frm formats beacon frm data frm ack frm mac cmd frm multipurpose frm ext frm","tags":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/tags/802-15-4/"}],"categories":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/categories/802-15-4/"}]},{"title":"802.15.4-mac_sec_related","date":"2025-03-08T02:54:19.000Z","path":"wiki/802-15-4-sec-related/","text":"以 drawio 流程图的形式介绍了 802.15.4(2015) mac layer 的加解密，主要有：incoming frm dec, outcoming frm enc, secure related PIBs。 注：802.15.4 2015&#x2F;2006&#x2F;2003 版本加解密flow上存在差异,点击流程图可以全屏展开 outgoing frm - enc incoming frm - sec on - dec incoming frm - sec on - dec sec pib related","tags":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/tags/802-15-4/"}],"categories":[{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/categories/802-15-4/"}]}],"categories":[{"name":"freeRTOS","slug":"freeRTOS","permalink":"http://example.com/categories/freeRTOS/"},{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/categories/802-15-4/"},{"name":"技术杂谈","slug":"技术杂谈","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"freeRTOS","slug":"freeRTOS","permalink":"http://example.com/tags/freeRTOS/"},{"name":"802.15.4","slug":"802-15-4","permalink":"http://example.com/tags/802-15-4/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}